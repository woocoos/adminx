// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/woocoos/adminx/ent/migrate"

	"github.com/woocoos/adminx/ent/app"
	"github.com/woocoos/adminx/ent/appmenu"
	"github.com/woocoos/adminx/ent/apppermission"
	"github.com/woocoos/adminx/ent/organization"
	"github.com/woocoos/adminx/ent/organizationuser"
	"github.com/woocoos/adminx/ent/user"
	"github.com/woocoos/adminx/ent/userdevice"
	"github.com/woocoos/adminx/ent/useridentity"
	"github.com/woocoos/adminx/ent/userloginprofile"
	"github.com/woocoos/adminx/ent/userpassword"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// App is the client for interacting with the App builders.
	App *AppClient
	// AppMenu is the client for interacting with the AppMenu builders.
	AppMenu *AppMenuClient
	// AppPermission is the client for interacting with the AppPermission builders.
	AppPermission *AppPermissionClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// OrganizationUser is the client for interacting with the OrganizationUser builders.
	OrganizationUser *OrganizationUserClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserDevice is the client for interacting with the UserDevice builders.
	UserDevice *UserDeviceClient
	// UserIdentity is the client for interacting with the UserIdentity builders.
	UserIdentity *UserIdentityClient
	// UserLoginProfile is the client for interacting with the UserLoginProfile builders.
	UserLoginProfile *UserLoginProfileClient
	// UserPassword is the client for interacting with the UserPassword builders.
	UserPassword *UserPasswordClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.App = NewAppClient(c.config)
	c.AppMenu = NewAppMenuClient(c.config)
	c.AppPermission = NewAppPermissionClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.OrganizationUser = NewOrganizationUserClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserDevice = NewUserDeviceClient(c.config)
	c.UserIdentity = NewUserIdentityClient(c.config)
	c.UserLoginProfile = NewUserLoginProfileClient(c.config)
	c.UserPassword = NewUserPasswordClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		App:              NewAppClient(cfg),
		AppMenu:          NewAppMenuClient(cfg),
		AppPermission:    NewAppPermissionClient(cfg),
		Organization:     NewOrganizationClient(cfg),
		OrganizationUser: NewOrganizationUserClient(cfg),
		User:             NewUserClient(cfg),
		UserDevice:       NewUserDeviceClient(cfg),
		UserIdentity:     NewUserIdentityClient(cfg),
		UserLoginProfile: NewUserLoginProfileClient(cfg),
		UserPassword:     NewUserPasswordClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		App:              NewAppClient(cfg),
		AppMenu:          NewAppMenuClient(cfg),
		AppPermission:    NewAppPermissionClient(cfg),
		Organization:     NewOrganizationClient(cfg),
		OrganizationUser: NewOrganizationUserClient(cfg),
		User:             NewUserClient(cfg),
		UserDevice:       NewUserDeviceClient(cfg),
		UserIdentity:     NewUserIdentityClient(cfg),
		UserLoginProfile: NewUserLoginProfileClient(cfg),
		UserPassword:     NewUserPasswordClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		App.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.App.Use(hooks...)
	c.AppMenu.Use(hooks...)
	c.AppPermission.Use(hooks...)
	c.Organization.Use(hooks...)
	c.OrganizationUser.Use(hooks...)
	c.User.Use(hooks...)
	c.UserDevice.Use(hooks...)
	c.UserIdentity.Use(hooks...)
	c.UserLoginProfile.Use(hooks...)
	c.UserPassword.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.App.Intercept(interceptors...)
	c.AppMenu.Intercept(interceptors...)
	c.AppPermission.Intercept(interceptors...)
	c.Organization.Intercept(interceptors...)
	c.OrganizationUser.Intercept(interceptors...)
	c.User.Intercept(interceptors...)
	c.UserDevice.Intercept(interceptors...)
	c.UserIdentity.Intercept(interceptors...)
	c.UserLoginProfile.Intercept(interceptors...)
	c.UserPassword.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AppMutation:
		return c.App.mutate(ctx, m)
	case *AppMenuMutation:
		return c.AppMenu.mutate(ctx, m)
	case *AppPermissionMutation:
		return c.AppPermission.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *OrganizationUserMutation:
		return c.OrganizationUser.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserDeviceMutation:
		return c.UserDevice.mutate(ctx, m)
	case *UserIdentityMutation:
		return c.UserIdentity.mutate(ctx, m)
	case *UserLoginProfileMutation:
		return c.UserLoginProfile.mutate(ctx, m)
	case *UserPasswordMutation:
		return c.UserPassword.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `app.Intercept(f(g(h())))`.
func (c *AppClient) Intercept(interceptors ...Interceptor) {
	c.inters.App = append(c.inters.App, interceptors...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id int) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id int) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApp},
		inters: c.Interceptors(),
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id int) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id int) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMenus queries the menus edge of a App.
func (c *AppClient) QueryMenus(a *App) *AppMenuQuery {
	query := (&AppMenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(appmenu.Table, appmenu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.MenusTable, app.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a App.
func (c *AppClient) QueryPermissions(a *App) *AppPermissionQuery {
	query := (&AppPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(apppermission.Table, apppermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.PermissionsTable, app.PermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	hooks := c.hooks.App
	return append(hooks[:len(hooks):len(hooks)], app.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AppClient) Interceptors() []Interceptor {
	return c.inters.App
}

func (c *AppClient) mutate(ctx context.Context, m *AppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown App mutation op: %q", m.Op())
	}
}

// AppMenuClient is a client for the AppMenu schema.
type AppMenuClient struct {
	config
}

// NewAppMenuClient returns a client for the AppMenu from the given config.
func NewAppMenuClient(c config) *AppMenuClient {
	return &AppMenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appmenu.Hooks(f(g(h())))`.
func (c *AppMenuClient) Use(hooks ...Hook) {
	c.hooks.AppMenu = append(c.hooks.AppMenu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appmenu.Intercept(f(g(h())))`.
func (c *AppMenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppMenu = append(c.inters.AppMenu, interceptors...)
}

// Create returns a builder for creating a AppMenu entity.
func (c *AppMenuClient) Create() *AppMenuCreate {
	mutation := newAppMenuMutation(c.config, OpCreate)
	return &AppMenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppMenu entities.
func (c *AppMenuClient) CreateBulk(builders ...*AppMenuCreate) *AppMenuCreateBulk {
	return &AppMenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppMenu.
func (c *AppMenuClient) Update() *AppMenuUpdate {
	mutation := newAppMenuMutation(c.config, OpUpdate)
	return &AppMenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppMenuClient) UpdateOne(am *AppMenu) *AppMenuUpdateOne {
	mutation := newAppMenuMutation(c.config, OpUpdateOne, withAppMenu(am))
	return &AppMenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppMenuClient) UpdateOneID(id int) *AppMenuUpdateOne {
	mutation := newAppMenuMutation(c.config, OpUpdateOne, withAppMenuID(id))
	return &AppMenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppMenu.
func (c *AppMenuClient) Delete() *AppMenuDelete {
	mutation := newAppMenuMutation(c.config, OpDelete)
	return &AppMenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppMenuClient) DeleteOne(am *AppMenu) *AppMenuDeleteOne {
	return c.DeleteOneID(am.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppMenuClient) DeleteOneID(id int) *AppMenuDeleteOne {
	builder := c.Delete().Where(appmenu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppMenuDeleteOne{builder}
}

// Query returns a query builder for AppMenu.
func (c *AppMenuClient) Query() *AppMenuQuery {
	return &AppMenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a AppMenu entity by its id.
func (c *AppMenuClient) Get(ctx context.Context, id int) (*AppMenu, error) {
	return c.Query().Where(appmenu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppMenuClient) GetX(ctx context.Context, id int) *AppMenu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a AppMenu.
func (c *AppMenuClient) QueryApp(am *AppMenu) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := am.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appmenu.Table, appmenu.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, appmenu.AppTable, appmenu.AppColumn),
		)
		fromV = sqlgraph.Neighbors(am.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermission queries the permission edge of a AppMenu.
func (c *AppMenuClient) QueryPermission(am *AppMenu) *AppPermissionQuery {
	query := (&AppPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := am.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appmenu.Table, appmenu.FieldID, id),
			sqlgraph.To(apppermission.Table, apppermission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, appmenu.PermissionTable, appmenu.PermissionColumn),
		)
		fromV = sqlgraph.Neighbors(am.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppMenuClient) Hooks() []Hook {
	hooks := c.hooks.AppMenu
	return append(hooks[:len(hooks):len(hooks)], appmenu.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AppMenuClient) Interceptors() []Interceptor {
	return c.inters.AppMenu
}

func (c *AppMenuClient) mutate(ctx context.Context, m *AppMenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppMenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppMenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppMenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppMenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AppMenu mutation op: %q", m.Op())
	}
}

// AppPermissionClient is a client for the AppPermission schema.
type AppPermissionClient struct {
	config
}

// NewAppPermissionClient returns a client for the AppPermission from the given config.
func NewAppPermissionClient(c config) *AppPermissionClient {
	return &AppPermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apppermission.Hooks(f(g(h())))`.
func (c *AppPermissionClient) Use(hooks ...Hook) {
	c.hooks.AppPermission = append(c.hooks.AppPermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apppermission.Intercept(f(g(h())))`.
func (c *AppPermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppPermission = append(c.inters.AppPermission, interceptors...)
}

// Create returns a builder for creating a AppPermission entity.
func (c *AppPermissionClient) Create() *AppPermissionCreate {
	mutation := newAppPermissionMutation(c.config, OpCreate)
	return &AppPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppPermission entities.
func (c *AppPermissionClient) CreateBulk(builders ...*AppPermissionCreate) *AppPermissionCreateBulk {
	return &AppPermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppPermission.
func (c *AppPermissionClient) Update() *AppPermissionUpdate {
	mutation := newAppPermissionMutation(c.config, OpUpdate)
	return &AppPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppPermissionClient) UpdateOne(ap *AppPermission) *AppPermissionUpdateOne {
	mutation := newAppPermissionMutation(c.config, OpUpdateOne, withAppPermission(ap))
	return &AppPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppPermissionClient) UpdateOneID(id int) *AppPermissionUpdateOne {
	mutation := newAppPermissionMutation(c.config, OpUpdateOne, withAppPermissionID(id))
	return &AppPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppPermission.
func (c *AppPermissionClient) Delete() *AppPermissionDelete {
	mutation := newAppPermissionMutation(c.config, OpDelete)
	return &AppPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppPermissionClient) DeleteOne(ap *AppPermission) *AppPermissionDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppPermissionClient) DeleteOneID(id int) *AppPermissionDeleteOne {
	builder := c.Delete().Where(apppermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppPermissionDeleteOne{builder}
}

// Query returns a query builder for AppPermission.
func (c *AppPermissionClient) Query() *AppPermissionQuery {
	return &AppPermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppPermission},
		inters: c.Interceptors(),
	}
}

// Get returns a AppPermission entity by its id.
func (c *AppPermissionClient) Get(ctx context.Context, id int) (*AppPermission, error) {
	return c.Query().Where(apppermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppPermissionClient) GetX(ctx context.Context, id int) *AppPermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a AppPermission.
func (c *AppPermissionClient) QueryApp(ap *AppPermission) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apppermission.Table, apppermission.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apppermission.AppTable, apppermission.AppColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a AppPermission.
func (c *AppPermissionClient) QueryMenus(ap *AppPermission) *AppMenuQuery {
	query := (&AppMenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apppermission.Table, apppermission.FieldID, id),
			sqlgraph.To(appmenu.Table, appmenu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, apppermission.MenusTable, apppermission.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppPermissionClient) Hooks() []Hook {
	hooks := c.hooks.AppPermission
	return append(hooks[:len(hooks):len(hooks)], apppermission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *AppPermissionClient) Interceptors() []Interceptor {
	return c.inters.AppPermission
}

func (c *AppPermissionClient) mutate(ctx context.Context, m *AppPermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AppPermission mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Organization.
func (c *OrganizationClient) QueryParent(o *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organization.ParentTable, organization.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Organization.
func (c *OrganizationClient) QueryChildren(o *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ChildrenTable, organization.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Organization.
func (c *OrganizationClient) QueryOwner(o *Organization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, organization.OwnerTable, organization.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Organization.
func (c *OrganizationClient) QueryUsers(o *Organization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, organization.UsersTable, organization.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizationUser queries the organization_user edge of a Organization.
func (c *OrganizationClient) QueryOrganizationUser(o *Organization) *OrganizationUserQuery {
	query := (&OrganizationUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organizationuser.Table, organizationuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, organization.OrganizationUserTable, organization.OrganizationUserColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	hooks := c.hooks.Organization
	return append(hooks[:len(hooks):len(hooks)], organization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	inters := c.inters.Organization
	return append(inters[:len(inters):len(inters)], organization.Interceptors[:]...)
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// OrganizationUserClient is a client for the OrganizationUser schema.
type OrganizationUserClient struct {
	config
}

// NewOrganizationUserClient returns a client for the OrganizationUser from the given config.
func NewOrganizationUserClient(c config) *OrganizationUserClient {
	return &OrganizationUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationuser.Hooks(f(g(h())))`.
func (c *OrganizationUserClient) Use(hooks ...Hook) {
	c.hooks.OrganizationUser = append(c.hooks.OrganizationUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationuser.Intercept(f(g(h())))`.
func (c *OrganizationUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationUser = append(c.inters.OrganizationUser, interceptors...)
}

// Create returns a builder for creating a OrganizationUser entity.
func (c *OrganizationUserClient) Create() *OrganizationUserCreate {
	mutation := newOrganizationUserMutation(c.config, OpCreate)
	return &OrganizationUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationUser entities.
func (c *OrganizationUserClient) CreateBulk(builders ...*OrganizationUserCreate) *OrganizationUserCreateBulk {
	return &OrganizationUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationUser.
func (c *OrganizationUserClient) Update() *OrganizationUserUpdate {
	mutation := newOrganizationUserMutation(c.config, OpUpdate)
	return &OrganizationUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationUserClient) UpdateOne(ou *OrganizationUser) *OrganizationUserUpdateOne {
	mutation := newOrganizationUserMutation(c.config, OpUpdateOne, withOrganizationUser(ou))
	return &OrganizationUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationUserClient) UpdateOneID(id int) *OrganizationUserUpdateOne {
	mutation := newOrganizationUserMutation(c.config, OpUpdateOne, withOrganizationUserID(id))
	return &OrganizationUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationUser.
func (c *OrganizationUserClient) Delete() *OrganizationUserDelete {
	mutation := newOrganizationUserMutation(c.config, OpDelete)
	return &OrganizationUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationUserClient) DeleteOne(ou *OrganizationUser) *OrganizationUserDeleteOne {
	return c.DeleteOneID(ou.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationUserClient) DeleteOneID(id int) *OrganizationUserDeleteOne {
	builder := c.Delete().Where(organizationuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationUserDeleteOne{builder}
}

// Query returns a query builder for OrganizationUser.
func (c *OrganizationUserClient) Query() *OrganizationUserQuery {
	return &OrganizationUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationUser},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationUser entity by its id.
func (c *OrganizationUserClient) Get(ctx context.Context, id int) (*OrganizationUser, error) {
	return c.Query().Where(organizationuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationUserClient) GetX(ctx context.Context, id int) *OrganizationUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrganizationUser.
func (c *OrganizationUserClient) QueryOrganization(ou *OrganizationUser) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationuser.Table, organizationuser.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, organizationuser.OrganizationTable, organizationuser.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OrganizationUser.
func (c *OrganizationUserClient) QueryUser(ou *OrganizationUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ou.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationuser.Table, organizationuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, organizationuser.UserTable, organizationuser.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ou.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationUserClient) Hooks() []Hook {
	hooks := c.hooks.OrganizationUser
	return append(hooks[:len(hooks):len(hooks)], organizationuser.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationUserClient) Interceptors() []Interceptor {
	return c.inters.OrganizationUser
}

func (c *OrganizationUserClient) mutate(ctx context.Context, m *OrganizationUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrganizationUser mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIdentities queries the identities edge of a User.
func (c *UserClient) QueryIdentities(u *User) *UserIdentityQuery {
	query := (&UserIdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(useridentity.Table, useridentity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.IdentitiesTable, user.IdentitiesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLoginProfile queries the login_profile edge of a User.
func (c *UserClient) QueryLoginProfile(u *User) *UserLoginProfileQuery {
	query := (&UserLoginProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userloginprofile.Table, userloginprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.LoginProfileTable, user.LoginProfileColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPasswords queries the passwords edge of a User.
func (c *UserClient) QueryPasswords(u *User) *UserPasswordQuery {
	query := (&UserPasswordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userpassword.Table, userpassword.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PasswordsTable, user.PasswordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevices queries the devices edge of a User.
func (c *UserClient) QueryDevices(u *User) *UserDeviceQuery {
	query := (&UserDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userdevice.Table, userdevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DevicesTable, user.DevicesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a User.
func (c *UserClient) QueryOrganizations(u *User) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.OrganizationsTable, user.OrganizationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizationUser queries the organization_user edge of a User.
func (c *UserClient) QueryOrganizationUser(u *User) *OrganizationUserQuery {
	query := (&OrganizationUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organizationuser.Table, organizationuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.OrganizationUserTable, user.OrganizationUserColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserDeviceClient is a client for the UserDevice schema.
type UserDeviceClient struct {
	config
}

// NewUserDeviceClient returns a client for the UserDevice from the given config.
func NewUserDeviceClient(c config) *UserDeviceClient {
	return &UserDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userdevice.Hooks(f(g(h())))`.
func (c *UserDeviceClient) Use(hooks ...Hook) {
	c.hooks.UserDevice = append(c.hooks.UserDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userdevice.Intercept(f(g(h())))`.
func (c *UserDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserDevice = append(c.inters.UserDevice, interceptors...)
}

// Create returns a builder for creating a UserDevice entity.
func (c *UserDeviceClient) Create() *UserDeviceCreate {
	mutation := newUserDeviceMutation(c.config, OpCreate)
	return &UserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserDevice entities.
func (c *UserDeviceClient) CreateBulk(builders ...*UserDeviceCreate) *UserDeviceCreateBulk {
	return &UserDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserDevice.
func (c *UserDeviceClient) Update() *UserDeviceUpdate {
	mutation := newUserDeviceMutation(c.config, OpUpdate)
	return &UserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserDeviceClient) UpdateOne(ud *UserDevice) *UserDeviceUpdateOne {
	mutation := newUserDeviceMutation(c.config, OpUpdateOne, withUserDevice(ud))
	return &UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserDeviceClient) UpdateOneID(id int) *UserDeviceUpdateOne {
	mutation := newUserDeviceMutation(c.config, OpUpdateOne, withUserDeviceID(id))
	return &UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserDevice.
func (c *UserDeviceClient) Delete() *UserDeviceDelete {
	mutation := newUserDeviceMutation(c.config, OpDelete)
	return &UserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserDeviceClient) DeleteOne(ud *UserDevice) *UserDeviceDeleteOne {
	return c.DeleteOneID(ud.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserDeviceClient) DeleteOneID(id int) *UserDeviceDeleteOne {
	builder := c.Delete().Where(userdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeviceDeleteOne{builder}
}

// Query returns a query builder for UserDevice.
func (c *UserDeviceClient) Query() *UserDeviceQuery {
	return &UserDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a UserDevice entity by its id.
func (c *UserDeviceClient) Get(ctx context.Context, id int) (*UserDevice, error) {
	return c.Query().Where(userdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserDeviceClient) GetX(ctx context.Context, id int) *UserDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserDevice.
func (c *UserDeviceClient) QueryUser(ud *UserDevice) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ud.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userdevice.Table, userdevice.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userdevice.UserTable, userdevice.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ud.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserDeviceClient) Hooks() []Hook {
	hooks := c.hooks.UserDevice
	return append(hooks[:len(hooks):len(hooks)], userdevice.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserDeviceClient) Interceptors() []Interceptor {
	return c.inters.UserDevice
}

func (c *UserDeviceClient) mutate(ctx context.Context, m *UserDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserDevice mutation op: %q", m.Op())
	}
}

// UserIdentityClient is a client for the UserIdentity schema.
type UserIdentityClient struct {
	config
}

// NewUserIdentityClient returns a client for the UserIdentity from the given config.
func NewUserIdentityClient(c config) *UserIdentityClient {
	return &UserIdentityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `useridentity.Hooks(f(g(h())))`.
func (c *UserIdentityClient) Use(hooks ...Hook) {
	c.hooks.UserIdentity = append(c.hooks.UserIdentity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `useridentity.Intercept(f(g(h())))`.
func (c *UserIdentityClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserIdentity = append(c.inters.UserIdentity, interceptors...)
}

// Create returns a builder for creating a UserIdentity entity.
func (c *UserIdentityClient) Create() *UserIdentityCreate {
	mutation := newUserIdentityMutation(c.config, OpCreate)
	return &UserIdentityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserIdentity entities.
func (c *UserIdentityClient) CreateBulk(builders ...*UserIdentityCreate) *UserIdentityCreateBulk {
	return &UserIdentityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserIdentity.
func (c *UserIdentityClient) Update() *UserIdentityUpdate {
	mutation := newUserIdentityMutation(c.config, OpUpdate)
	return &UserIdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserIdentityClient) UpdateOne(ui *UserIdentity) *UserIdentityUpdateOne {
	mutation := newUserIdentityMutation(c.config, OpUpdateOne, withUserIdentity(ui))
	return &UserIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserIdentityClient) UpdateOneID(id int) *UserIdentityUpdateOne {
	mutation := newUserIdentityMutation(c.config, OpUpdateOne, withUserIdentityID(id))
	return &UserIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserIdentity.
func (c *UserIdentityClient) Delete() *UserIdentityDelete {
	mutation := newUserIdentityMutation(c.config, OpDelete)
	return &UserIdentityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserIdentityClient) DeleteOne(ui *UserIdentity) *UserIdentityDeleteOne {
	return c.DeleteOneID(ui.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserIdentityClient) DeleteOneID(id int) *UserIdentityDeleteOne {
	builder := c.Delete().Where(useridentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserIdentityDeleteOne{builder}
}

// Query returns a query builder for UserIdentity.
func (c *UserIdentityClient) Query() *UserIdentityQuery {
	return &UserIdentityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserIdentity},
		inters: c.Interceptors(),
	}
}

// Get returns a UserIdentity entity by its id.
func (c *UserIdentityClient) Get(ctx context.Context, id int) (*UserIdentity, error) {
	return c.Query().Where(useridentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserIdentityClient) GetX(ctx context.Context, id int) *UserIdentity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserIdentity.
func (c *UserIdentityClient) QueryUser(ui *UserIdentity) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ui.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(useridentity.Table, useridentity.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, useridentity.UserTable, useridentity.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ui.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserIdentityClient) Hooks() []Hook {
	hooks := c.hooks.UserIdentity
	return append(hooks[:len(hooks):len(hooks)], useridentity.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserIdentityClient) Interceptors() []Interceptor {
	return c.inters.UserIdentity
}

func (c *UserIdentityClient) mutate(ctx context.Context, m *UserIdentityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserIdentityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserIdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserIdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserIdentityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserIdentity mutation op: %q", m.Op())
	}
}

// UserLoginProfileClient is a client for the UserLoginProfile schema.
type UserLoginProfileClient struct {
	config
}

// NewUserLoginProfileClient returns a client for the UserLoginProfile from the given config.
func NewUserLoginProfileClient(c config) *UserLoginProfileClient {
	return &UserLoginProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userloginprofile.Hooks(f(g(h())))`.
func (c *UserLoginProfileClient) Use(hooks ...Hook) {
	c.hooks.UserLoginProfile = append(c.hooks.UserLoginProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userloginprofile.Intercept(f(g(h())))`.
func (c *UserLoginProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserLoginProfile = append(c.inters.UserLoginProfile, interceptors...)
}

// Create returns a builder for creating a UserLoginProfile entity.
func (c *UserLoginProfileClient) Create() *UserLoginProfileCreate {
	mutation := newUserLoginProfileMutation(c.config, OpCreate)
	return &UserLoginProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserLoginProfile entities.
func (c *UserLoginProfileClient) CreateBulk(builders ...*UserLoginProfileCreate) *UserLoginProfileCreateBulk {
	return &UserLoginProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserLoginProfile.
func (c *UserLoginProfileClient) Update() *UserLoginProfileUpdate {
	mutation := newUserLoginProfileMutation(c.config, OpUpdate)
	return &UserLoginProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserLoginProfileClient) UpdateOne(ulp *UserLoginProfile) *UserLoginProfileUpdateOne {
	mutation := newUserLoginProfileMutation(c.config, OpUpdateOne, withUserLoginProfile(ulp))
	return &UserLoginProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserLoginProfileClient) UpdateOneID(id int) *UserLoginProfileUpdateOne {
	mutation := newUserLoginProfileMutation(c.config, OpUpdateOne, withUserLoginProfileID(id))
	return &UserLoginProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserLoginProfile.
func (c *UserLoginProfileClient) Delete() *UserLoginProfileDelete {
	mutation := newUserLoginProfileMutation(c.config, OpDelete)
	return &UserLoginProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserLoginProfileClient) DeleteOne(ulp *UserLoginProfile) *UserLoginProfileDeleteOne {
	return c.DeleteOneID(ulp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserLoginProfileClient) DeleteOneID(id int) *UserLoginProfileDeleteOne {
	builder := c.Delete().Where(userloginprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserLoginProfileDeleteOne{builder}
}

// Query returns a query builder for UserLoginProfile.
func (c *UserLoginProfileClient) Query() *UserLoginProfileQuery {
	return &UserLoginProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserLoginProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a UserLoginProfile entity by its id.
func (c *UserLoginProfileClient) Get(ctx context.Context, id int) (*UserLoginProfile, error) {
	return c.Query().Where(userloginprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserLoginProfileClient) GetX(ctx context.Context, id int) *UserLoginProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserLoginProfile.
func (c *UserLoginProfileClient) QueryUser(ulp *UserLoginProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ulp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userloginprofile.Table, userloginprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, userloginprofile.UserTable, userloginprofile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ulp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserLoginProfileClient) Hooks() []Hook {
	hooks := c.hooks.UserLoginProfile
	return append(hooks[:len(hooks):len(hooks)], userloginprofile.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserLoginProfileClient) Interceptors() []Interceptor {
	return c.inters.UserLoginProfile
}

func (c *UserLoginProfileClient) mutate(ctx context.Context, m *UserLoginProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserLoginProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserLoginProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserLoginProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserLoginProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserLoginProfile mutation op: %q", m.Op())
	}
}

// UserPasswordClient is a client for the UserPassword schema.
type UserPasswordClient struct {
	config
}

// NewUserPasswordClient returns a client for the UserPassword from the given config.
func NewUserPasswordClient(c config) *UserPasswordClient {
	return &UserPasswordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userpassword.Hooks(f(g(h())))`.
func (c *UserPasswordClient) Use(hooks ...Hook) {
	c.hooks.UserPassword = append(c.hooks.UserPassword, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userpassword.Intercept(f(g(h())))`.
func (c *UserPasswordClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserPassword = append(c.inters.UserPassword, interceptors...)
}

// Create returns a builder for creating a UserPassword entity.
func (c *UserPasswordClient) Create() *UserPasswordCreate {
	mutation := newUserPasswordMutation(c.config, OpCreate)
	return &UserPasswordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserPassword entities.
func (c *UserPasswordClient) CreateBulk(builders ...*UserPasswordCreate) *UserPasswordCreateBulk {
	return &UserPasswordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserPassword.
func (c *UserPasswordClient) Update() *UserPasswordUpdate {
	mutation := newUserPasswordMutation(c.config, OpUpdate)
	return &UserPasswordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserPasswordClient) UpdateOne(up *UserPassword) *UserPasswordUpdateOne {
	mutation := newUserPasswordMutation(c.config, OpUpdateOne, withUserPassword(up))
	return &UserPasswordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserPasswordClient) UpdateOneID(id int) *UserPasswordUpdateOne {
	mutation := newUserPasswordMutation(c.config, OpUpdateOne, withUserPasswordID(id))
	return &UserPasswordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserPassword.
func (c *UserPasswordClient) Delete() *UserPasswordDelete {
	mutation := newUserPasswordMutation(c.config, OpDelete)
	return &UserPasswordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserPasswordClient) DeleteOne(up *UserPassword) *UserPasswordDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserPasswordClient) DeleteOneID(id int) *UserPasswordDeleteOne {
	builder := c.Delete().Where(userpassword.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserPasswordDeleteOne{builder}
}

// Query returns a query builder for UserPassword.
func (c *UserPasswordClient) Query() *UserPasswordQuery {
	return &UserPasswordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserPassword},
		inters: c.Interceptors(),
	}
}

// Get returns a UserPassword entity by its id.
func (c *UserPasswordClient) Get(ctx context.Context, id int) (*UserPassword, error) {
	return c.Query().Where(userpassword.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserPasswordClient) GetX(ctx context.Context, id int) *UserPassword {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserPassword.
func (c *UserPasswordClient) QueryUser(up *UserPassword) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userpassword.Table, userpassword.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userpassword.UserTable, userpassword.UserColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserPasswordClient) Hooks() []Hook {
	hooks := c.hooks.UserPassword
	return append(hooks[:len(hooks):len(hooks)], userpassword.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserPasswordClient) Interceptors() []Interceptor {
	return c.inters.UserPassword
}

func (c *UserPasswordClient) mutate(ctx context.Context, m *UserPasswordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserPasswordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserPasswordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserPasswordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserPasswordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserPassword mutation op: %q", m.Op())
	}
}
