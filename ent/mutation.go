// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/woocoos/adminx/ent/app"
	"github.com/woocoos/adminx/ent/appmenu"
	"github.com/woocoos/adminx/ent/apppermission"
	"github.com/woocoos/adminx/ent/organization"
	"github.com/woocoos/adminx/ent/organizationuser"
	"github.com/woocoos/adminx/ent/predicate"
	"github.com/woocoos/adminx/ent/user"
	"github.com/woocoos/adminx/ent/userdevice"
	"github.com/woocoos/adminx/ent/useridentity"
	"github.com/woocoos/adminx/ent/userloginprofile"
	"github.com/woocoos/adminx/ent/userpassword"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp              = "App"
	TypeAppMenu          = "AppMenu"
	TypeAppPermission    = "AppPermission"
	TypeOrganization     = "Organization"
	TypeOrganizationUser = "OrganizationUser"
	TypeUser             = "User"
	TypeUserDevice       = "UserDevice"
	TypeUserIdentity     = "UserIdentity"
	TypeUserLoginProfile = "UserLoginProfile"
	TypeUserPassword     = "UserPassword"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_by                *int
	addcreated_by             *int
	created_at                *time.Time
	updated_by                *int
	addupdated_by             *int
	updated_at                *time.Time
	name                      *string
	code                      *string
	kind                      *app.Kind
	redirect_uri              *string
	app_key                   *string
	app_secret                *string
	scopes                    *string
	token_validity            *int32
	addtoken_validity         *int32
	refresh_token_validity    *int32
	addrefresh_token_validity *int32
	logo                      *string
	comments                  *string
	status                    *app.Status
	clearedFields             map[string]struct{}
	menus                     map[int]struct{}
	removedmenus              map[int]struct{}
	clearedmenus              bool
	permissions               map[int]struct{}
	removedpermissions        map[int]struct{}
	clearedpermissions        bool
	done                      bool
	oldValue                  func(context.Context) (*App, error)
	predicates                []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[app.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[app.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, app.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[app.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[app.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, app.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *AppMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AppMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AppMutation) ResetCode() {
	m.code = nil
}

// SetKind sets the "kind" field.
func (m *AppMutation) SetKind(a app.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppMutation) Kind() (r app.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldKind(ctx context.Context) (v app.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppMutation) ResetKind() {
	m.kind = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AppMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AppMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ClearRedirectURI clears the value of the "redirect_uri" field.
func (m *AppMutation) ClearRedirectURI() {
	m.redirect_uri = nil
	m.clearedFields[app.FieldRedirectURI] = struct{}{}
}

// RedirectURICleared returns if the "redirect_uri" field was cleared in this mutation.
func (m *AppMutation) RedirectURICleared() bool {
	_, ok := m.clearedFields[app.FieldRedirectURI]
	return ok
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AppMutation) ResetRedirectURI() {
	m.redirect_uri = nil
	delete(m.clearedFields, app.FieldRedirectURI)
}

// SetAppKey sets the "app_key" field.
func (m *AppMutation) SetAppKey(s string) {
	m.app_key = &s
}

// AppKey returns the value of the "app_key" field in the mutation.
func (m *AppMutation) AppKey() (r string, exists bool) {
	v := m.app_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAppKey returns the old "app_key" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppKey: %w", err)
	}
	return oldValue.AppKey, nil
}

// ClearAppKey clears the value of the "app_key" field.
func (m *AppMutation) ClearAppKey() {
	m.app_key = nil
	m.clearedFields[app.FieldAppKey] = struct{}{}
}

// AppKeyCleared returns if the "app_key" field was cleared in this mutation.
func (m *AppMutation) AppKeyCleared() bool {
	_, ok := m.clearedFields[app.FieldAppKey]
	return ok
}

// ResetAppKey resets all changes to the "app_key" field.
func (m *AppMutation) ResetAppKey() {
	m.app_key = nil
	delete(m.clearedFields, app.FieldAppKey)
}

// SetAppSecret sets the "app_secret" field.
func (m *AppMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the value of the "app_secret" field in the mutation.
func (m *AppMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old "app_secret" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ClearAppSecret clears the value of the "app_secret" field.
func (m *AppMutation) ClearAppSecret() {
	m.app_secret = nil
	m.clearedFields[app.FieldAppSecret] = struct{}{}
}

// AppSecretCleared returns if the "app_secret" field was cleared in this mutation.
func (m *AppMutation) AppSecretCleared() bool {
	_, ok := m.clearedFields[app.FieldAppSecret]
	return ok
}

// ResetAppSecret resets all changes to the "app_secret" field.
func (m *AppMutation) ResetAppSecret() {
	m.app_secret = nil
	delete(m.clearedFields, app.FieldAppSecret)
}

// SetScopes sets the "scopes" field.
func (m *AppMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *AppMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ClearScopes clears the value of the "scopes" field.
func (m *AppMutation) ClearScopes() {
	m.scopes = nil
	m.clearedFields[app.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *AppMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[app.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *AppMutation) ResetScopes() {
	m.scopes = nil
	delete(m.clearedFields, app.FieldScopes)
}

// SetTokenValidity sets the "token_validity" field.
func (m *AppMutation) SetTokenValidity(i int32) {
	m.token_validity = &i
	m.addtoken_validity = nil
}

// TokenValidity returns the value of the "token_validity" field in the mutation.
func (m *AppMutation) TokenValidity() (r int32, exists bool) {
	v := m.token_validity
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenValidity returns the old "token_validity" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldTokenValidity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenValidity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenValidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenValidity: %w", err)
	}
	return oldValue.TokenValidity, nil
}

// AddTokenValidity adds i to the "token_validity" field.
func (m *AppMutation) AddTokenValidity(i int32) {
	if m.addtoken_validity != nil {
		*m.addtoken_validity += i
	} else {
		m.addtoken_validity = &i
	}
}

// AddedTokenValidity returns the value that was added to the "token_validity" field in this mutation.
func (m *AppMutation) AddedTokenValidity() (r int32, exists bool) {
	v := m.addtoken_validity
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokenValidity clears the value of the "token_validity" field.
func (m *AppMutation) ClearTokenValidity() {
	m.token_validity = nil
	m.addtoken_validity = nil
	m.clearedFields[app.FieldTokenValidity] = struct{}{}
}

// TokenValidityCleared returns if the "token_validity" field was cleared in this mutation.
func (m *AppMutation) TokenValidityCleared() bool {
	_, ok := m.clearedFields[app.FieldTokenValidity]
	return ok
}

// ResetTokenValidity resets all changes to the "token_validity" field.
func (m *AppMutation) ResetTokenValidity() {
	m.token_validity = nil
	m.addtoken_validity = nil
	delete(m.clearedFields, app.FieldTokenValidity)
}

// SetRefreshTokenValidity sets the "refresh_token_validity" field.
func (m *AppMutation) SetRefreshTokenValidity(i int32) {
	m.refresh_token_validity = &i
	m.addrefresh_token_validity = nil
}

// RefreshTokenValidity returns the value of the "refresh_token_validity" field in the mutation.
func (m *AppMutation) RefreshTokenValidity() (r int32, exists bool) {
	v := m.refresh_token_validity
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenValidity returns the old "refresh_token_validity" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRefreshTokenValidity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenValidity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenValidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenValidity: %w", err)
	}
	return oldValue.RefreshTokenValidity, nil
}

// AddRefreshTokenValidity adds i to the "refresh_token_validity" field.
func (m *AppMutation) AddRefreshTokenValidity(i int32) {
	if m.addrefresh_token_validity != nil {
		*m.addrefresh_token_validity += i
	} else {
		m.addrefresh_token_validity = &i
	}
}

// AddedRefreshTokenValidity returns the value that was added to the "refresh_token_validity" field in this mutation.
func (m *AppMutation) AddedRefreshTokenValidity() (r int32, exists bool) {
	v := m.addrefresh_token_validity
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefreshTokenValidity clears the value of the "refresh_token_validity" field.
func (m *AppMutation) ClearRefreshTokenValidity() {
	m.refresh_token_validity = nil
	m.addrefresh_token_validity = nil
	m.clearedFields[app.FieldRefreshTokenValidity] = struct{}{}
}

// RefreshTokenValidityCleared returns if the "refresh_token_validity" field was cleared in this mutation.
func (m *AppMutation) RefreshTokenValidityCleared() bool {
	_, ok := m.clearedFields[app.FieldRefreshTokenValidity]
	return ok
}

// ResetRefreshTokenValidity resets all changes to the "refresh_token_validity" field.
func (m *AppMutation) ResetRefreshTokenValidity() {
	m.refresh_token_validity = nil
	m.addrefresh_token_validity = nil
	delete(m.clearedFields, app.FieldRefreshTokenValidity)
}

// SetLogo sets the "logo" field.
func (m *AppMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *AppMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *AppMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[app.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *AppMutation) LogoCleared() bool {
	_, ok := m.clearedFields[app.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *AppMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, app.FieldLogo)
}

// SetComments sets the "comments" field.
func (m *AppMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[app.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[app.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, app.FieldComments)
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(a app.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r app.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v app.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *AppMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[app.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppMutation) StatusCleared() bool {
	_, ok := m.clearedFields[app.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, app.FieldStatus)
}

// AddMenuIDs adds the "menus" edge to the AppMenu entity by ids.
func (m *AppMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AppMenu entity.
func (m *AppMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AppMenu entity was cleared.
func (m *AppMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AppMenu entity by IDs.
func (m *AppMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AppMenu entity.
func (m *AppMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AppMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AppMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddPermissionIDs adds the "permissions" edge to the AppPermission entity by ids.
func (m *AppMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the AppPermission entity.
func (m *AppMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the AppPermission entity was cleared.
func (m *AppMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the AppPermission entity by IDs.
func (m *AppMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the AppPermission entity.
func (m *AppMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *AppMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *AppMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.code != nil {
		fields = append(fields, app.FieldCode)
	}
	if m.kind != nil {
		fields = append(fields, app.FieldKind)
	}
	if m.redirect_uri != nil {
		fields = append(fields, app.FieldRedirectURI)
	}
	if m.app_key != nil {
		fields = append(fields, app.FieldAppKey)
	}
	if m.app_secret != nil {
		fields = append(fields, app.FieldAppSecret)
	}
	if m.scopes != nil {
		fields = append(fields, app.FieldScopes)
	}
	if m.token_validity != nil {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.refresh_token_validity != nil {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	if m.logo != nil {
		fields = append(fields, app.FieldLogo)
	}
	if m.comments != nil {
		fields = append(fields, app.FieldComments)
	}
	if m.status != nil {
		fields = append(fields, app.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedBy:
		return m.CreatedBy()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedBy:
		return m.UpdatedBy()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldName:
		return m.Name()
	case app.FieldCode:
		return m.Code()
	case app.FieldKind:
		return m.Kind()
	case app.FieldRedirectURI:
		return m.RedirectURI()
	case app.FieldAppKey:
		return m.AppKey()
	case app.FieldAppSecret:
		return m.AppSecret()
	case app.FieldScopes:
		return m.Scopes()
	case app.FieldTokenValidity:
		return m.TokenValidity()
	case app.FieldRefreshTokenValidity:
		return m.RefreshTokenValidity()
	case app.FieldLogo:
		return m.Logo()
	case app.FieldComments:
		return m.Comments()
	case app.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldCode:
		return m.OldCode(ctx)
	case app.FieldKind:
		return m.OldKind(ctx)
	case app.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case app.FieldAppKey:
		return m.OldAppKey(ctx)
	case app.FieldAppSecret:
		return m.OldAppSecret(ctx)
	case app.FieldScopes:
		return m.OldScopes(ctx)
	case app.FieldTokenValidity:
		return m.OldTokenValidity(ctx)
	case app.FieldRefreshTokenValidity:
		return m.OldRefreshTokenValidity(ctx)
	case app.FieldLogo:
		return m.OldLogo(ctx)
	case app.FieldComments:
		return m.OldComments(ctx)
	case app.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case app.FieldKind:
		v, ok := value.(app.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case app.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case app.FieldAppKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppKey(v)
		return nil
	case app.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	case app.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case app.FieldTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenValidity(v)
		return nil
	case app.FieldRefreshTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenValidity(v)
		return nil
	case app.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case app.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(app.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.addtoken_validity != nil {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.addrefresh_token_validity != nil {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedBy:
		return m.AddedCreatedBy()
	case app.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case app.FieldTokenValidity:
		return m.AddedTokenValidity()
	case app.FieldRefreshTokenValidity:
		return m.AddedRefreshTokenValidity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case app.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case app.FieldTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenValidity(v)
		return nil
	case app.FieldRefreshTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTokenValidity(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldUpdatedBy) {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.FieldCleared(app.FieldUpdatedAt) {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.FieldCleared(app.FieldRedirectURI) {
		fields = append(fields, app.FieldRedirectURI)
	}
	if m.FieldCleared(app.FieldAppKey) {
		fields = append(fields, app.FieldAppKey)
	}
	if m.FieldCleared(app.FieldAppSecret) {
		fields = append(fields, app.FieldAppSecret)
	}
	if m.FieldCleared(app.FieldScopes) {
		fields = append(fields, app.FieldScopes)
	}
	if m.FieldCleared(app.FieldTokenValidity) {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.FieldCleared(app.FieldRefreshTokenValidity) {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	if m.FieldCleared(app.FieldLogo) {
		fields = append(fields, app.FieldLogo)
	}
	if m.FieldCleared(app.FieldComments) {
		fields = append(fields, app.FieldComments)
	}
	if m.FieldCleared(app.FieldStatus) {
		fields = append(fields, app.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case app.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case app.FieldRedirectURI:
		m.ClearRedirectURI()
		return nil
	case app.FieldAppKey:
		m.ClearAppKey()
		return nil
	case app.FieldAppSecret:
		m.ClearAppSecret()
		return nil
	case app.FieldScopes:
		m.ClearScopes()
		return nil
	case app.FieldTokenValidity:
		m.ClearTokenValidity()
		return nil
	case app.FieldRefreshTokenValidity:
		m.ClearRefreshTokenValidity()
		return nil
	case app.FieldLogo:
		m.ClearLogo()
		return nil
	case app.FieldComments:
		m.ClearComments()
		return nil
	case app.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldCode:
		m.ResetCode()
		return nil
	case app.FieldKind:
		m.ResetKind()
		return nil
	case app.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case app.FieldAppKey:
		m.ResetAppKey()
		return nil
	case app.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	case app.FieldScopes:
		m.ResetScopes()
		return nil
	case app.FieldTokenValidity:
		m.ResetTokenValidity()
		return nil
	case app.FieldRefreshTokenValidity:
		m.ResetRefreshTokenValidity()
		return nil
	case app.FieldLogo:
		m.ResetLogo()
		return nil
	case app.FieldComments:
		m.ResetComments()
		return nil
	case app.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menus != nil {
		edges = append(edges, app.EdgeMenus)
	}
	if m.permissions != nil {
		edges = append(edges, app.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenus != nil {
		edges = append(edges, app.EdgeMenus)
	}
	if m.removedpermissions != nil {
		edges = append(edges, app.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenus {
		edges = append(edges, app.EdgeMenus)
	}
	if m.clearedpermissions {
		edges = append(edges, app.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeMenus:
		return m.clearedmenus
	case app.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeMenus:
		m.ResetMenus()
		return nil
	case app.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppMenuMutation represents an operation that mutates the AppMenu nodes in the graph.
type AppMenuMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_by        *int
	addcreated_by     *int
	created_at        *time.Time
	updated_by        *int
	addupdated_by     *int
	updated_at        *time.Time
	parent_id         *int
	addparent_id      *int
	kind              *appmenu.Kind
	name              *string
	comments          *string
	display_sort      *int32
	adddisplay_sort   *int32
	clearedFields     map[string]struct{}
	app               *int
	clearedapp        bool
	permission        *int
	clearedpermission bool
	done              bool
	oldValue          func(context.Context) (*AppMenu, error)
	predicates        []predicate.AppMenu
}

var _ ent.Mutation = (*AppMenuMutation)(nil)

// appmenuOption allows management of the mutation configuration using functional options.
type appmenuOption func(*AppMenuMutation)

// newAppMenuMutation creates new mutation for the AppMenu entity.
func newAppMenuMutation(c config, op Op, opts ...appmenuOption) *AppMenuMutation {
	m := &AppMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeAppMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppMenuID sets the ID field of the mutation.
func withAppMenuID(id int) appmenuOption {
	return func(m *AppMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *AppMenu
		)
		m.oldValue = func(ctx context.Context) (*AppMenu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppMenu sets the old AppMenu of the mutation.
func withAppMenu(node *AppMenu) appmenuOption {
	return func(m *AppMenuMutation) {
		m.oldValue = func(context.Context) (*AppMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppMenu entities.
func (m *AppMenuMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMenuMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppMenu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMenuMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMenuMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppMenuMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppMenuMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMenuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppMenuMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppMenuMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppMenuMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppMenuMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppMenuMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[appmenu.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppMenuMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppMenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, appmenu.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppMenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appmenu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppMenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appmenu.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppMenuMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppMenuMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppMenuMutation) ResetAppID() {
	m.app = nil
}

// SetParentID sets the "parent_id" field.
func (m *AppMenuMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AppMenuMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *AppMenuMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *AppMenuMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AppMenuMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetKind sets the "kind" field.
func (m *AppMenuMutation) SetKind(a appmenu.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppMenuMutation) Kind() (r appmenu.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldKind(ctx context.Context) (v appmenu.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppMenuMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *AppMenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppMenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[appmenu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppMenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppMenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appmenu.FieldName)
}

// SetPermissionID sets the "permission_id" field.
func (m *AppMenuMutation) SetPermissionID(i int) {
	m.permission = &i
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *AppMenuMutation) PermissionID() (r int, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldPermissionID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ClearPermissionID clears the value of the "permission_id" field.
func (m *AppMenuMutation) ClearPermissionID() {
	m.permission = nil
	m.clearedFields[appmenu.FieldPermissionID] = struct{}{}
}

// PermissionIDCleared returns if the "permission_id" field was cleared in this mutation.
func (m *AppMenuMutation) PermissionIDCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldPermissionID]
	return ok
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *AppMenuMutation) ResetPermissionID() {
	m.permission = nil
	delete(m.clearedFields, appmenu.FieldPermissionID)
}

// SetComments sets the "comments" field.
func (m *AppMenuMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppMenuMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppMenuMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[appmenu.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppMenuMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppMenuMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, appmenu.FieldComments)
}

// SetDisplaySort sets the "display_sort" field.
func (m *AppMenuMutation) SetDisplaySort(i int32) {
	m.display_sort = &i
	m.adddisplay_sort = nil
}

// DisplaySort returns the value of the "display_sort" field in the mutation.
func (m *AppMenuMutation) DisplaySort() (r int32, exists bool) {
	v := m.display_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplaySort returns the old "display_sort" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldDisplaySort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplaySort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplaySort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplaySort: %w", err)
	}
	return oldValue.DisplaySort, nil
}

// AddDisplaySort adds i to the "display_sort" field.
func (m *AppMenuMutation) AddDisplaySort(i int32) {
	if m.adddisplay_sort != nil {
		*m.adddisplay_sort += i
	} else {
		m.adddisplay_sort = &i
	}
}

// AddedDisplaySort returns the value that was added to the "display_sort" field in this mutation.
func (m *AppMenuMutation) AddedDisplaySort() (r int32, exists bool) {
	v := m.adddisplay_sort
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplaySort clears the value of the "display_sort" field.
func (m *AppMenuMutation) ClearDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	m.clearedFields[appmenu.FieldDisplaySort] = struct{}{}
}

// DisplaySortCleared returns if the "display_sort" field was cleared in this mutation.
func (m *AppMenuMutation) DisplaySortCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldDisplaySort]
	return ok
}

// ResetDisplaySort resets all changes to the "display_sort" field.
func (m *AppMenuMutation) ResetDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	delete(m.clearedFields, appmenu.FieldDisplaySort)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppMenuMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppMenuMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppMenuMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppMenuMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearPermission clears the "permission" edge to the AppPermission entity.
func (m *AppMenuMutation) ClearPermission() {
	m.clearedpermission = true
}

// PermissionCleared reports if the "permission" edge to the AppPermission entity was cleared.
func (m *AppMenuMutation) PermissionCleared() bool {
	return m.PermissionIDCleared() || m.clearedpermission
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionID instead. It exists only for internal usage by the builders.
func (m *AppMenuMutation) PermissionIDs() (ids []int) {
	if id := m.permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *AppMenuMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
}

// Where appends a list predicates to the AppMenuMutation builder.
func (m *AppMenuMutation) Where(ps ...predicate.AppMenu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppMenu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppMenu).
func (m *AppMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMenuMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, appmenu.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, appmenu.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, appmenu.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appmenu.FieldAppID)
	}
	if m.parent_id != nil {
		fields = append(fields, appmenu.FieldParentID)
	}
	if m.kind != nil {
		fields = append(fields, appmenu.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, appmenu.FieldName)
	}
	if m.permission != nil {
		fields = append(fields, appmenu.FieldPermissionID)
	}
	if m.comments != nil {
		fields = append(fields, appmenu.FieldComments)
	}
	if m.display_sort != nil {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.CreatedBy()
	case appmenu.FieldCreatedAt:
		return m.CreatedAt()
	case appmenu.FieldUpdatedBy:
		return m.UpdatedBy()
	case appmenu.FieldUpdatedAt:
		return m.UpdatedAt()
	case appmenu.FieldAppID:
		return m.AppID()
	case appmenu.FieldParentID:
		return m.ParentID()
	case appmenu.FieldKind:
		return m.Kind()
	case appmenu.FieldName:
		return m.Name()
	case appmenu.FieldPermissionID:
		return m.PermissionID()
	case appmenu.FieldComments:
		return m.Comments()
	case appmenu.FieldDisplaySort:
		return m.DisplaySort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case appmenu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appmenu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case appmenu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appmenu.FieldAppID:
		return m.OldAppID(ctx)
	case appmenu.FieldParentID:
		return m.OldParentID(ctx)
	case appmenu.FieldKind:
		return m.OldKind(ctx)
	case appmenu.FieldName:
		return m.OldName(ctx)
	case appmenu.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case appmenu.FieldComments:
		return m.OldComments(ctx)
	case appmenu.FieldDisplaySort:
		return m.OldDisplaySort(ctx)
	}
	return nil, fmt.Errorf("unknown AppMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appmenu.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case appmenu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appmenu.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case appmenu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appmenu.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appmenu.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case appmenu.FieldKind:
		v, ok := value.(appmenu.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case appmenu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appmenu.FieldPermissionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case appmenu.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case appmenu.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown AppMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, appmenu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.addparent_id != nil {
		fields = append(fields, appmenu.FieldParentID)
	}
	if m.adddisplay_sort != nil {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case appmenu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case appmenu.FieldParentID:
		return m.AddedParentID()
	case appmenu.FieldDisplaySort:
		return m.AddedDisplaySort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appmenu.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case appmenu.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case appmenu.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case appmenu.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown AppMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appmenu.FieldUpdatedBy) {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.FieldCleared(appmenu.FieldUpdatedAt) {
		fields = append(fields, appmenu.FieldUpdatedAt)
	}
	if m.FieldCleared(appmenu.FieldName) {
		fields = append(fields, appmenu.FieldName)
	}
	if m.FieldCleared(appmenu.FieldPermissionID) {
		fields = append(fields, appmenu.FieldPermissionID)
	}
	if m.FieldCleared(appmenu.FieldComments) {
		fields = append(fields, appmenu.FieldComments)
	}
	if m.FieldCleared(appmenu.FieldDisplaySort) {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMenuMutation) ClearField(name string) error {
	switch name {
	case appmenu.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case appmenu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appmenu.FieldName:
		m.ClearName()
		return nil
	case appmenu.FieldPermissionID:
		m.ClearPermissionID()
		return nil
	case appmenu.FieldComments:
		m.ClearComments()
		return nil
	case appmenu.FieldDisplaySort:
		m.ClearDisplaySort()
		return nil
	}
	return fmt.Errorf("unknown AppMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMenuMutation) ResetField(name string) error {
	switch name {
	case appmenu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case appmenu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appmenu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case appmenu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appmenu.FieldAppID:
		m.ResetAppID()
		return nil
	case appmenu.FieldParentID:
		m.ResetParentID()
		return nil
	case appmenu.FieldKind:
		m.ResetKind()
		return nil
	case appmenu.FieldName:
		m.ResetName()
		return nil
	case appmenu.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case appmenu.FieldComments:
		m.ResetComments()
		return nil
	case appmenu.FieldDisplaySort:
		m.ResetDisplaySort()
		return nil
	}
	return fmt.Errorf("unknown AppMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appmenu.EdgeApp)
	}
	if m.permission != nil {
		edges = append(edges, appmenu.EdgePermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appmenu.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appmenu.EdgePermission:
		if id := m.permission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appmenu.EdgeApp)
	}
	if m.clearedpermission {
		edges = append(edges, appmenu.EdgePermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMenuMutation) EdgeCleared(name string) bool {
	switch name {
	case appmenu.EdgeApp:
		return m.clearedapp
	case appmenu.EdgePermission:
		return m.clearedpermission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMenuMutation) ClearEdge(name string) error {
	switch name {
	case appmenu.EdgeApp:
		m.ClearApp()
		return nil
	case appmenu.EdgePermission:
		m.ClearPermission()
		return nil
	}
	return fmt.Errorf("unknown AppMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMenuMutation) ResetEdge(name string) error {
	switch name {
	case appmenu.EdgeApp:
		m.ResetApp()
		return nil
	case appmenu.EdgePermission:
		m.ResetPermission()
		return nil
	}
	return fmt.Errorf("unknown AppMenu edge %s", name)
}

// AppPermissionMutation represents an operation that mutates the AppPermission nodes in the graph.
type AppPermissionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	name          *string
	kind          *apppermission.Kind
	comments      *string
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	menus         map[int]struct{}
	removedmenus  map[int]struct{}
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*AppPermission, error)
	predicates    []predicate.AppPermission
}

var _ ent.Mutation = (*AppPermissionMutation)(nil)

// apppermissionOption allows management of the mutation configuration using functional options.
type apppermissionOption func(*AppPermissionMutation)

// newAppPermissionMutation creates new mutation for the AppPermission entity.
func newAppPermissionMutation(c config, op Op, opts ...apppermissionOption) *AppPermissionMutation {
	m := &AppPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPermissionID sets the ID field of the mutation.
func withAppPermissionID(id int) apppermissionOption {
	return func(m *AppPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPermission
		)
		m.oldValue = func(ctx context.Context) (*AppPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPermission sets the old AppPermission of the mutation.
func withAppPermission(node *AppPermission) apppermissionOption {
	return func(m *AppPermissionMutation) {
		m.oldValue = func(context.Context) (*AppPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPermission entities.
func (m *AppPermissionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppPermissionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppPermissionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppPermissionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppPermissionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppPermissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppPermissionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppPermissionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppPermissionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppPermissionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppPermissionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[apppermission.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppPermissionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[apppermission.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppPermissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, apppermission.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppPermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[apppermission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppPermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[apppermission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, apppermission.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppPermissionMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppPermissionMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppPermissionMutation) ResetAppID() {
	m.app = nil
}

// SetName sets the "name" field.
func (m *AppPermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppPermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppPermissionMutation) ClearName() {
	m.name = nil
	m.clearedFields[apppermission.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppPermissionMutation) NameCleared() bool {
	_, ok := m.clearedFields[apppermission.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppPermissionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, apppermission.FieldName)
}

// SetKind sets the "kind" field.
func (m *AppPermissionMutation) SetKind(a apppermission.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppPermissionMutation) Kind() (r apppermission.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldKind(ctx context.Context) (v apppermission.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *AppPermissionMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[apppermission.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *AppPermissionMutation) KindCleared() bool {
	_, ok := m.clearedFields[apppermission.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *AppPermissionMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, apppermission.FieldKind)
}

// SetComments sets the "comments" field.
func (m *AppPermissionMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppPermissionMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppPermission entity.
// If the AppPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermissionMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppPermissionMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[apppermission.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppPermissionMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[apppermission.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppPermissionMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, apppermission.FieldComments)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppPermissionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppPermissionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppPermissionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppPermissionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddMenuIDs adds the "menus" edge to the AppMenu entity by ids.
func (m *AppPermissionMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AppMenu entity.
func (m *AppPermissionMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AppMenu entity was cleared.
func (m *AppPermissionMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AppMenu entity by IDs.
func (m *AppPermissionMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AppMenu entity.
func (m *AppPermissionMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AppPermissionMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AppPermissionMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Where appends a list predicates to the AppPermissionMutation builder.
func (m *AppPermissionMutation) Where(ps ...predicate.AppPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPermission).
func (m *AppPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPermissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, apppermission.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, apppermission.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, apppermission.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, apppermission.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, apppermission.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, apppermission.FieldName)
	}
	if m.kind != nil {
		fields = append(fields, apppermission.FieldKind)
	}
	if m.comments != nil {
		fields = append(fields, apppermission.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppermission.FieldCreatedBy:
		return m.CreatedBy()
	case apppermission.FieldCreatedAt:
		return m.CreatedAt()
	case apppermission.FieldUpdatedBy:
		return m.UpdatedBy()
	case apppermission.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppermission.FieldAppID:
		return m.AppID()
	case apppermission.FieldName:
		return m.Name()
	case apppermission.FieldKind:
		return m.Kind()
	case apppermission.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppermission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case apppermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apppermission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case apppermission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppermission.FieldAppID:
		return m.OldAppID(ctx)
	case apppermission.FieldName:
		return m.OldName(ctx)
	case apppermission.FieldKind:
		return m.OldKind(ctx)
	case apppermission.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown AppPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppermission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case apppermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apppermission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case apppermission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppermission.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case apppermission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apppermission.FieldKind:
		v, ok := value.(apppermission.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case apppermission.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown AppPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPermissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, apppermission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, apppermission.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppermission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case apppermission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppermission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case apppermission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apppermission.FieldUpdatedBy) {
		fields = append(fields, apppermission.FieldUpdatedBy)
	}
	if m.FieldCleared(apppermission.FieldUpdatedAt) {
		fields = append(fields, apppermission.FieldUpdatedAt)
	}
	if m.FieldCleared(apppermission.FieldName) {
		fields = append(fields, apppermission.FieldName)
	}
	if m.FieldCleared(apppermission.FieldKind) {
		fields = append(fields, apppermission.FieldKind)
	}
	if m.FieldCleared(apppermission.FieldComments) {
		fields = append(fields, apppermission.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPermissionMutation) ClearField(name string) error {
	switch name {
	case apppermission.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case apppermission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case apppermission.FieldName:
		m.ClearName()
		return nil
	case apppermission.FieldKind:
		m.ClearKind()
		return nil
	case apppermission.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown AppPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPermissionMutation) ResetField(name string) error {
	switch name {
	case apppermission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case apppermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apppermission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case apppermission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppermission.FieldAppID:
		m.ResetAppID()
		return nil
	case apppermission.FieldName:
		m.ResetName()
		return nil
	case apppermission.FieldKind:
		m.ResetKind()
		return nil
	case apppermission.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown AppPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, apppermission.EdgeApp)
	}
	if m.menus != nil {
		edges = append(edges, apppermission.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apppermission.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case apppermission.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenus != nil {
		edges = append(edges, apppermission.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apppermission.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, apppermission.EdgeApp)
	}
	if m.clearedmenus {
		edges = append(edges, apppermission.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case apppermission.EdgeApp:
		return m.clearedapp
	case apppermission.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPermissionMutation) ClearEdge(name string) error {
	switch name {
	case apppermission.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPermissionMutation) ResetEdge(name string) error {
	switch name {
	case apppermission.EdgeApp:
		m.ResetApp()
		return nil
	case apppermission.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown AppPermission edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_by               *int
	addcreated_by            *int
	created_at               *time.Time
	updated_by               *int
	addupdated_by            *int
	updated_at               *time.Time
	deleted_at               *time.Time
	kind                     *organization.Kind
	domain                   *string
	code                     *string
	name                     *string
	profile                  *string
	status                   *organization.Status
	_path                    *string
	display_sort             *int32
	adddisplay_sort          *int32
	country_code             *string
	timezone                 *string
	clearedFields            map[string]struct{}
	parent                   *int
	clearedparent            bool
	children                 map[int]struct{}
	removedchildren          map[int]struct{}
	clearedchildren          bool
	owner                    *int
	clearedowner             bool
	users                    map[int]struct{}
	removedusers             map[int]struct{}
	clearedusers             bool
	organization_user        map[int]struct{}
	removedorganization_user map[int]struct{}
	clearedorganization_user bool
	done                     bool
	oldValue                 func(context.Context) (*Organization, error)
	predicates               []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrganizationMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrganizationMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrganizationMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrganizationMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[organization.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, organization.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organization.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organization.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organization.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organization.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *OrganizationMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OrganizationMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *OrganizationMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[organization.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *OrganizationMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OrganizationMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, organization.FieldOwnerID)
}

// SetKind sets the "kind" field.
func (m *OrganizationMutation) SetKind(o organization.Kind) {
	m.kind = &o
}

// Kind returns the value of the "kind" field in the mutation.
func (m *OrganizationMutation) Kind() (r organization.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldKind(ctx context.Context) (v organization.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *OrganizationMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[organization.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *OrganizationMutation) KindCleared() bool {
	_, ok := m.clearedFields[organization.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *OrganizationMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, organization.FieldKind)
}

// SetParentID sets the "parent_id" field.
func (m *OrganizationMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrganizationMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrganizationMutation) ResetParentID() {
	m.parent = nil
}

// SetDomain sets the "domain" field.
func (m *OrganizationMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *OrganizationMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *OrganizationMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[organization.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *OrganizationMutation) DomainCleared() bool {
	_, ok := m.clearedFields[organization.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *OrganizationMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, organization.FieldDomain)
}

// SetCode sets the "code" field.
func (m *OrganizationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrganizationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *OrganizationMutation) ClearCode() {
	m.code = nil
	m.clearedFields[organization.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *OrganizationMutation) CodeCleared() bool {
	_, ok := m.clearedFields[organization.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *OrganizationMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, organization.FieldCode)
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetProfile sets the "profile" field.
func (m *OrganizationMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *OrganizationMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *OrganizationMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[organization.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *OrganizationMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[organization.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *OrganizationMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, organization.FieldProfile)
}

// SetStatus sets the "status" field.
func (m *OrganizationMutation) SetStatus(o organization.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMutation) Status() (r organization.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStatus(ctx context.Context) (v organization.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *OrganizationMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[organization.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrganizationMutation) StatusCleared() bool {
	_, ok := m.clearedFields[organization.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, organization.FieldStatus)
}

// SetPath sets the "path" field.
func (m *OrganizationMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *OrganizationMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *OrganizationMutation) ClearPath() {
	m._path = nil
	m.clearedFields[organization.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *OrganizationMutation) PathCleared() bool {
	_, ok := m.clearedFields[organization.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *OrganizationMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, organization.FieldPath)
}

// SetDisplaySort sets the "display_sort" field.
func (m *OrganizationMutation) SetDisplaySort(i int32) {
	m.display_sort = &i
	m.adddisplay_sort = nil
}

// DisplaySort returns the value of the "display_sort" field in the mutation.
func (m *OrganizationMutation) DisplaySort() (r int32, exists bool) {
	v := m.display_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplaySort returns the old "display_sort" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDisplaySort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplaySort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplaySort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplaySort: %w", err)
	}
	return oldValue.DisplaySort, nil
}

// AddDisplaySort adds i to the "display_sort" field.
func (m *OrganizationMutation) AddDisplaySort(i int32) {
	if m.adddisplay_sort != nil {
		*m.adddisplay_sort += i
	} else {
		m.adddisplay_sort = &i
	}
}

// AddedDisplaySort returns the value that was added to the "display_sort" field in this mutation.
func (m *OrganizationMutation) AddedDisplaySort() (r int32, exists bool) {
	v := m.adddisplay_sort
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplaySort clears the value of the "display_sort" field.
func (m *OrganizationMutation) ClearDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	m.clearedFields[organization.FieldDisplaySort] = struct{}{}
}

// DisplaySortCleared returns if the "display_sort" field was cleared in this mutation.
func (m *OrganizationMutation) DisplaySortCleared() bool {
	_, ok := m.clearedFields[organization.FieldDisplaySort]
	return ok
}

// ResetDisplaySort resets all changes to the "display_sort" field.
func (m *OrganizationMutation) ResetDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	delete(m.clearedFields, organization.FieldDisplaySort)
}

// SetCountryCode sets the "country_code" field.
func (m *OrganizationMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *OrganizationMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *OrganizationMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[organization.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *OrganizationMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[organization.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *OrganizationMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, organization.FieldCountryCode)
}

// SetTimezone sets the "timezone" field.
func (m *OrganizationMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OrganizationMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OrganizationMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[organization.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OrganizationMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[organization.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OrganizationMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, organization.FieldTimezone)
}

// ClearParent clears the "parent" edge to the Organization entity.
func (m *OrganizationMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrganizationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Organization entity by ids.
func (m *OrganizationMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Organization entity.
func (m *OrganizationMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Organization entity by IDs.
func (m *OrganizationMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Organization entity.
func (m *OrganizationMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrganizationMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrganizationMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *OrganizationMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *OrganizationMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrganizationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddOrganizationUserIDs adds the "organization_user" edge to the OrganizationUser entity by ids.
func (m *OrganizationMutation) AddOrganizationUserIDs(ids ...int) {
	if m.organization_user == nil {
		m.organization_user = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_user[ids[i]] = struct{}{}
	}
}

// ClearOrganizationUser clears the "organization_user" edge to the OrganizationUser entity.
func (m *OrganizationMutation) ClearOrganizationUser() {
	m.clearedorganization_user = true
}

// OrganizationUserCleared reports if the "organization_user" edge to the OrganizationUser entity was cleared.
func (m *OrganizationMutation) OrganizationUserCleared() bool {
	return m.clearedorganization_user
}

// RemoveOrganizationUserIDs removes the "organization_user" edge to the OrganizationUser entity by IDs.
func (m *OrganizationMutation) RemoveOrganizationUserIDs(ids ...int) {
	if m.removedorganization_user == nil {
		m.removedorganization_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_user, ids[i])
		m.removedorganization_user[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationUser returns the removed IDs of the "organization_user" edge to the OrganizationUser entity.
func (m *OrganizationMutation) RemovedOrganizationUserIDs() (ids []int) {
	for id := range m.removedorganization_user {
		ids = append(ids, id)
	}
	return
}

// OrganizationUserIDs returns the "organization_user" edge IDs in the mutation.
func (m *OrganizationMutation) OrganizationUserIDs() (ids []int) {
	for id := range m.organization_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationUser resets all changes to the "organization_user" edge.
func (m *OrganizationMutation) ResetOrganizationUser() {
	m.organization_user = nil
	m.clearedorganization_user = false
	m.removedorganization_user = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.owner != nil {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.kind != nil {
		fields = append(fields, organization.FieldKind)
	}
	if m.parent != nil {
		fields = append(fields, organization.FieldParentID)
	}
	if m.domain != nil {
		fields = append(fields, organization.FieldDomain)
	}
	if m.code != nil {
		fields = append(fields, organization.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.profile != nil {
		fields = append(fields, organization.FieldProfile)
	}
	if m.status != nil {
		fields = append(fields, organization.FieldStatus)
	}
	if m._path != nil {
		fields = append(fields, organization.FieldPath)
	}
	if m.display_sort != nil {
		fields = append(fields, organization.FieldDisplaySort)
	}
	if m.country_code != nil {
		fields = append(fields, organization.FieldCountryCode)
	}
	if m.timezone != nil {
		fields = append(fields, organization.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedBy:
		return m.CreatedBy()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldDeletedAt:
		return m.DeletedAt()
	case organization.FieldOwnerID:
		return m.OwnerID()
	case organization.FieldKind:
		return m.Kind()
	case organization.FieldParentID:
		return m.ParentID()
	case organization.FieldDomain:
		return m.Domain()
	case organization.FieldCode:
		return m.Code()
	case organization.FieldName:
		return m.Name()
	case organization.FieldProfile:
		return m.Profile()
	case organization.FieldStatus:
		return m.Status()
	case organization.FieldPath:
		return m.Path()
	case organization.FieldDisplaySort:
		return m.DisplaySort()
	case organization.FieldCountryCode:
		return m.CountryCode()
	case organization.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organization.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case organization.FieldKind:
		return m.OldKind(ctx)
	case organization.FieldParentID:
		return m.OldParentID(ctx)
	case organization.FieldDomain:
		return m.OldDomain(ctx)
	case organization.FieldCode:
		return m.OldCode(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldProfile:
		return m.OldProfile(ctx)
	case organization.FieldStatus:
		return m.OldStatus(ctx)
	case organization.FieldPath:
		return m.OldPath(ctx)
	case organization.FieldDisplaySort:
		return m.OldDisplaySort(ctx)
	case organization.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case organization.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organization.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case organization.FieldKind:
		v, ok := value.(organization.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case organization.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case organization.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case organization.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case organization.FieldStatus:
		v, ok := value.(organization.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organization.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case organization.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplaySort(v)
		return nil
	case organization.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case organization.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.adddisplay_sort != nil {
		fields = append(fields, organization.FieldDisplaySort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedBy:
		return m.AddedCreatedBy()
	case organization.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case organization.FieldDisplaySort:
		return m.AddedDisplaySort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case organization.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldUpdatedBy) {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.FieldCleared(organization.FieldUpdatedAt) {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.FieldCleared(organization.FieldDeletedAt) {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.FieldCleared(organization.FieldOwnerID) {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.FieldCleared(organization.FieldKind) {
		fields = append(fields, organization.FieldKind)
	}
	if m.FieldCleared(organization.FieldDomain) {
		fields = append(fields, organization.FieldDomain)
	}
	if m.FieldCleared(organization.FieldCode) {
		fields = append(fields, organization.FieldCode)
	}
	if m.FieldCleared(organization.FieldProfile) {
		fields = append(fields, organization.FieldProfile)
	}
	if m.FieldCleared(organization.FieldStatus) {
		fields = append(fields, organization.FieldStatus)
	}
	if m.FieldCleared(organization.FieldPath) {
		fields = append(fields, organization.FieldPath)
	}
	if m.FieldCleared(organization.FieldDisplaySort) {
		fields = append(fields, organization.FieldDisplaySort)
	}
	if m.FieldCleared(organization.FieldCountryCode) {
		fields = append(fields, organization.FieldCountryCode)
	}
	if m.FieldCleared(organization.FieldTimezone) {
		fields = append(fields, organization.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organization.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organization.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organization.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case organization.FieldKind:
		m.ClearKind()
		return nil
	case organization.FieldDomain:
		m.ClearDomain()
		return nil
	case organization.FieldCode:
		m.ClearCode()
		return nil
	case organization.FieldProfile:
		m.ClearProfile()
		return nil
	case organization.FieldStatus:
		m.ClearStatus()
		return nil
	case organization.FieldPath:
		m.ClearPath()
		return nil
	case organization.FieldDisplaySort:
		m.ClearDisplaySort()
		return nil
	case organization.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case organization.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organization.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case organization.FieldKind:
		m.ResetKind()
		return nil
	case organization.FieldParentID:
		m.ResetParentID()
		return nil
	case organization.FieldDomain:
		m.ResetDomain()
		return nil
	case organization.FieldCode:
		m.ResetCode()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldProfile:
		m.ResetProfile()
		return nil
	case organization.FieldStatus:
		m.ResetStatus()
		return nil
	case organization.FieldPath:
		m.ResetPath()
		return nil
	case organization.FieldDisplaySort:
		m.ResetDisplaySort()
		return nil
	case organization.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case organization.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.parent != nil {
		edges = append(edges, organization.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.owner != nil {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.organization_user != nil {
		edges = append(edges, organization.EdgeOrganizationUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.organization_user))
		for id := range m.organization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedorganization_user != nil {
		edges = append(edges, organization.EdgeOrganizationUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.removedorganization_user))
		for id := range m.removedorganization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedparent {
		edges = append(edges, organization.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.clearedowner {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedorganization_user {
		edges = append(edges, organization.EdgeOrganizationUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeParent:
		return m.clearedparent
	case organization.EdgeChildren:
		return m.clearedchildren
	case organization.EdgeOwner:
		return m.clearedowner
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeOrganizationUser:
		return m.clearedorganization_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ClearParent()
		return nil
	case organization.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ResetParent()
		return nil
	case organization.EdgeChildren:
		m.ResetChildren()
		return nil
	case organization.EdgeOwner:
		m.ResetOwner()
		return nil
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeOrganizationUser:
		m.ResetOrganizationUser()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationUserMutation represents an operation that mutates the OrganizationUser nodes in the graph.
type OrganizationUserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_by          *int
	addcreated_by       *int
	created_at          *time.Time
	updated_by          *int
	addupdated_by       *int
	updated_at          *time.Time
	display_name        *string
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*OrganizationUser, error)
	predicates          []predicate.OrganizationUser
}

var _ ent.Mutation = (*OrganizationUserMutation)(nil)

// organizationuserOption allows management of the mutation configuration using functional options.
type organizationuserOption func(*OrganizationUserMutation)

// newOrganizationUserMutation creates new mutation for the OrganizationUser entity.
func newOrganizationUserMutation(c config, op Op, opts ...organizationuserOption) *OrganizationUserMutation {
	m := &OrganizationUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationUserID sets the ID field of the mutation.
func withOrganizationUserID(id int) organizationuserOption {
	return func(m *OrganizationUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationUser
		)
		m.oldValue = func(ctx context.Context) (*OrganizationUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationUser sets the old OrganizationUser of the mutation.
func withOrganizationUser(node *OrganizationUser) organizationuserOption {
	return func(m *OrganizationUserMutation) {
		m.oldValue = func(context.Context) (*OrganizationUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationUser entities.
func (m *OrganizationUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationUserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationUserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrganizationUserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrganizationUserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationUserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationUserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationUserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrganizationUserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrganizationUserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationUserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[organizationuser.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationUserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationuser.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationUserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, organizationuser.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationUserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationuser.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationUserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationuser.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationuser.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrganizationUserMutation) SetOrgID(i int) {
	m.organization = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrganizationUserMutation) OrgID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrganizationUserMutation) ResetOrgID() {
	m.organization = nil
}

// SetUserID sets the "user_id" field.
func (m *OrganizationUserMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrganizationUserMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrganizationUserMutation) ResetUserID() {
	m.user = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationUserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationUserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationUserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationUserMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationUserMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationUserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationUserMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationUserMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationUserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationUserMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OrganizationUserMutation builder.
func (m *OrganizationUserMutation) Where(ps ...predicate.OrganizationUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationUser).
func (m *OrganizationUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, organizationuser.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, organizationuser.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationuser.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationuser.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationuser.FieldOrgID)
	}
	if m.user != nil {
		fields = append(fields, organizationuser.FieldUserID)
	}
	if m.display_name != nil {
		fields = append(fields, organizationuser.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationuser.FieldCreatedBy:
		return m.CreatedBy()
	case organizationuser.FieldCreatedAt:
		return m.CreatedAt()
	case organizationuser.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationuser.FieldOrgID:
		return m.OrgID()
	case organizationuser.FieldUserID:
		return m.UserID()
	case organizationuser.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationuser.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationuser.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationuser.FieldOrgID:
		return m.OldOrgID(ctx)
	case organizationuser.FieldUserID:
		return m.OldUserID(ctx)
	case organizationuser.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationuser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationuser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationuser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case organizationuser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case organizationuser.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, organizationuser.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, organizationuser.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationuser.FieldCreatedBy:
		return m.AddedCreatedBy()
	case organizationuser.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationuser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case organizationuser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationuser.FieldUpdatedBy) {
		fields = append(fields, organizationuser.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationuser.FieldUpdatedAt) {
		fields = append(fields, organizationuser.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationUserMutation) ClearField(name string) error {
	switch name {
	case organizationuser.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationuser.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationUserMutation) ResetField(name string) error {
	switch name {
	case organizationuser.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationuser.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationuser.FieldOrgID:
		m.ResetOrgID()
		return nil
	case organizationuser.FieldUserID:
		m.ResetUserID()
		return nil
	case organizationuser.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationuser.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, organizationuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationuser.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationuser.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, organizationuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationUserMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationuser.EdgeOrganization:
		return m.clearedorganization
	case organizationuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationUserMutation) ClearEdge(name string) error {
	switch name {
	case organizationuser.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationUserMutation) ResetEdge(name string) error {
	switch name {
	case organizationuser.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_by               *int
	addcreated_by            *int
	created_at               *time.Time
	updated_by               *int
	addupdated_by            *int
	updated_at               *time.Time
	deleted_at               *time.Time
	principal_name           *string
	display_name             *string
	user_type                *user.UserType
	creation_type            *user.CreationType
	register_ip              *string
	status                   *user.Status
	comments                 *string
	clearedFields            map[string]struct{}
	identities               map[int]struct{}
	removedidentities        map[int]struct{}
	clearedidentities        bool
	login_profile            *int
	clearedlogin_profile     bool
	passwords                map[int]struct{}
	removedpasswords         map[int]struct{}
	clearedpasswords         bool
	devices                  map[int]struct{}
	removeddevices           map[int]struct{}
	cleareddevices           bool
	organizations            map[int]struct{}
	removedorganizations     map[int]struct{}
	clearedorganizations     bool
	organization_user        map[int]struct{}
	removedorganization_user map[int]struct{}
	clearedorganization_user bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetPrincipalName sets the "principal_name" field.
func (m *UserMutation) SetPrincipalName(s string) {
	m.principal_name = &s
}

// PrincipalName returns the value of the "principal_name" field in the mutation.
func (m *UserMutation) PrincipalName() (r string, exists bool) {
	v := m.principal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipalName returns the old "principal_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrincipalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipalName: %w", err)
	}
	return oldValue.PrincipalName, nil
}

// ResetPrincipalName resets all changes to the "principal_name" field.
func (m *UserMutation) ResetPrincipalName() {
	m.principal_name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(ut user.UserType) {
	m.user_type = &ut
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r user.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v user.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetCreationType sets the "creation_type" field.
func (m *UserMutation) SetCreationType(ut user.CreationType) {
	m.creation_type = &ut
}

// CreationType returns the value of the "creation_type" field in the mutation.
func (m *UserMutation) CreationType() (r user.CreationType, exists bool) {
	v := m.creation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationType returns the old "creation_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreationType(ctx context.Context) (v user.CreationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationType: %w", err)
	}
	return oldValue.CreationType, nil
}

// ResetCreationType resets all changes to the "creation_type" field.
func (m *UserMutation) ResetCreationType() {
	m.creation_type = nil
}

// SetRegisterIP sets the "register_ip" field.
func (m *UserMutation) SetRegisterIP(s string) {
	m.register_ip = &s
}

// RegisterIP returns the value of the "register_ip" field in the mutation.
func (m *UserMutation) RegisterIP() (r string, exists bool) {
	v := m.register_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterIP returns the old "register_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegisterIP(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterIP: %w", err)
	}
	return oldValue.RegisterIP, nil
}

// ResetRegisterIP resets all changes to the "register_ip" field.
func (m *UserMutation) ResetRegisterIP() {
	m.register_ip = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetComments sets the "comments" field.
func (m *UserMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *UserMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *UserMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[user.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *UserMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[user.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, user.FieldComments)
}

// AddIdentityIDs adds the "identities" edge to the UserIdentity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...int) {
	if m.identities == nil {
		m.identities = make(map[int]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the UserIdentity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the UserIdentity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the UserIdentity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...int) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the UserIdentity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []int) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []int) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// SetLoginProfileID sets the "login_profile" edge to the UserLoginProfile entity by id.
func (m *UserMutation) SetLoginProfileID(id int) {
	m.login_profile = &id
}

// ClearLoginProfile clears the "login_profile" edge to the UserLoginProfile entity.
func (m *UserMutation) ClearLoginProfile() {
	m.clearedlogin_profile = true
}

// LoginProfileCleared reports if the "login_profile" edge to the UserLoginProfile entity was cleared.
func (m *UserMutation) LoginProfileCleared() bool {
	return m.clearedlogin_profile
}

// LoginProfileID returns the "login_profile" edge ID in the mutation.
func (m *UserMutation) LoginProfileID() (id int, exists bool) {
	if m.login_profile != nil {
		return *m.login_profile, true
	}
	return
}

// LoginProfileIDs returns the "login_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LoginProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LoginProfileIDs() (ids []int) {
	if id := m.login_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLoginProfile resets all changes to the "login_profile" edge.
func (m *UserMutation) ResetLoginProfile() {
	m.login_profile = nil
	m.clearedlogin_profile = false
}

// AddPasswordIDs adds the "passwords" edge to the UserPassword entity by ids.
func (m *UserMutation) AddPasswordIDs(ids ...int) {
	if m.passwords == nil {
		m.passwords = make(map[int]struct{})
	}
	for i := range ids {
		m.passwords[ids[i]] = struct{}{}
	}
}

// ClearPasswords clears the "passwords" edge to the UserPassword entity.
func (m *UserMutation) ClearPasswords() {
	m.clearedpasswords = true
}

// PasswordsCleared reports if the "passwords" edge to the UserPassword entity was cleared.
func (m *UserMutation) PasswordsCleared() bool {
	return m.clearedpasswords
}

// RemovePasswordIDs removes the "passwords" edge to the UserPassword entity by IDs.
func (m *UserMutation) RemovePasswordIDs(ids ...int) {
	if m.removedpasswords == nil {
		m.removedpasswords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passwords, ids[i])
		m.removedpasswords[ids[i]] = struct{}{}
	}
}

// RemovedPasswords returns the removed IDs of the "passwords" edge to the UserPassword entity.
func (m *UserMutation) RemovedPasswordsIDs() (ids []int) {
	for id := range m.removedpasswords {
		ids = append(ids, id)
	}
	return
}

// PasswordsIDs returns the "passwords" edge IDs in the mutation.
func (m *UserMutation) PasswordsIDs() (ids []int) {
	for id := range m.passwords {
		ids = append(ids, id)
	}
	return
}

// ResetPasswords resets all changes to the "passwords" edge.
func (m *UserMutation) ResetPasswords() {
	m.passwords = nil
	m.clearedpasswords = false
	m.removedpasswords = nil
}

// AddDeviceIDs adds the "devices" edge to the UserDevice entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int) {
	if m.devices == nil {
		m.devices = make(map[int]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the UserDevice entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the UserDevice entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the UserDevice entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the UserDevice entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *UserMutation) AddOrganizationIDs(ids ...int) {
	if m.organizations == nil {
		m.organizations = make(map[int]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *UserMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *UserMutation) RemovedOrganizationsIDs() (ids []int) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *UserMutation) OrganizationsIDs() (ids []int) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *UserMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddOrganizationUserIDs adds the "organization_user" edge to the OrganizationUser entity by ids.
func (m *UserMutation) AddOrganizationUserIDs(ids ...int) {
	if m.organization_user == nil {
		m.organization_user = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_user[ids[i]] = struct{}{}
	}
}

// ClearOrganizationUser clears the "organization_user" edge to the OrganizationUser entity.
func (m *UserMutation) ClearOrganizationUser() {
	m.clearedorganization_user = true
}

// OrganizationUserCleared reports if the "organization_user" edge to the OrganizationUser entity was cleared.
func (m *UserMutation) OrganizationUserCleared() bool {
	return m.clearedorganization_user
}

// RemoveOrganizationUserIDs removes the "organization_user" edge to the OrganizationUser entity by IDs.
func (m *UserMutation) RemoveOrganizationUserIDs(ids ...int) {
	if m.removedorganization_user == nil {
		m.removedorganization_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_user, ids[i])
		m.removedorganization_user[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationUser returns the removed IDs of the "organization_user" edge to the OrganizationUser entity.
func (m *UserMutation) RemovedOrganizationUserIDs() (ids []int) {
	for id := range m.removedorganization_user {
		ids = append(ids, id)
	}
	return
}

// OrganizationUserIDs returns the "organization_user" edge IDs in the mutation.
func (m *UserMutation) OrganizationUserIDs() (ids []int) {
	for id := range m.organization_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationUser resets all changes to the "organization_user" edge.
func (m *UserMutation) ResetOrganizationUser() {
	m.organization_user = nil
	m.clearedorganization_user = false
	m.removedorganization_user = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.principal_name != nil {
		fields = append(fields, user.FieldPrincipalName)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.creation_type != nil {
		fields = append(fields, user.FieldCreationType)
	}
	if m.register_ip != nil {
		fields = append(fields, user.FieldRegisterIP)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.comments != nil {
		fields = append(fields, user.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldPrincipalName:
		return m.PrincipalName()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldCreationType:
		return m.CreationType()
	case user.FieldRegisterIP:
		return m.RegisterIP()
	case user.FieldStatus:
		return m.Status()
	case user.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldPrincipalName:
		return m.OldPrincipalName(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldCreationType:
		return m.OldCreationType(ctx)
	case user.FieldRegisterIP:
		return m.OldRegisterIP(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldPrincipalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipalName(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(user.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldCreationType:
		v, ok := value.(user.CreationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationType(v)
		return nil
	case user.FieldRegisterIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterIP(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldComments) {
		fields = append(fields, user.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldPrincipalName:
		m.ResetPrincipalName()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldCreationType:
		m.ResetCreationType()
		return nil
	case user.FieldRegisterIP:
		m.ResetRegisterIP()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.login_profile != nil {
		edges = append(edges, user.EdgeLoginProfile)
	}
	if m.passwords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.organizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.organization_user != nil {
		edges = append(edges, user.EdgeOrganizationUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginProfile:
		if id := m.login_profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.passwords))
		for id := range m.passwords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.organization_user))
		for id := range m.organization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedpasswords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedorganizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.removedorganization_user != nil {
		edges = append(edges, user.EdgeOrganizationUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.removedpasswords))
		for id := range m.removedpasswords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.removedorganization_user))
		for id := range m.removedorganization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedlogin_profile {
		edges = append(edges, user.EdgeLoginProfile)
	}
	if m.clearedpasswords {
		edges = append(edges, user.EdgePasswords)
	}
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedorganizations {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.clearedorganization_user {
		edges = append(edges, user.EdgeOrganizationUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeLoginProfile:
		return m.clearedlogin_profile
	case user.EdgePasswords:
		return m.clearedpasswords
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeOrganizations:
		return m.clearedorganizations
	case user.EdgeOrganizationUser:
		return m.clearedorganization_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLoginProfile:
		m.ClearLoginProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeLoginProfile:
		m.ResetLoginProfile()
		return nil
	case user.EdgePasswords:
		m.ResetPasswords()
		return nil
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case user.EdgeOrganizationUser:
		m.ResetOrganizationUser()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_by     *int
	addcreated_by  *int
	created_at     *time.Time
	updated_by     *int
	addupdated_by  *int
	updated_at     *time.Time
	device_uid     *string
	device_name    *string
	system_name    *string
	system_version *string
	app_version    *string
	device_model   *string
	status         *userdevice.Status
	comments       *string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserDevice, error)
	predicates     []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id int) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDevice entities.
func (m *UserDeviceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserDeviceMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserDeviceMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserDeviceMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserDeviceMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserDeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserDeviceMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserDeviceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserDeviceMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserDeviceMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserDeviceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userdevice.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserDeviceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserDeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userdevice.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserDeviceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userdevice.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserDeviceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userdevice.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserDeviceMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userdevice.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserDeviceMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userdevice.FieldUserID)
}

// SetDeviceUID sets the "device_uid" field.
func (m *UserDeviceMutation) SetDeviceUID(s string) {
	m.device_uid = &s
}

// DeviceUID returns the value of the "device_uid" field in the mutation.
func (m *UserDeviceMutation) DeviceUID() (r string, exists bool) {
	v := m.device_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceUID returns the old "device_uid" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceUID: %w", err)
	}
	return oldValue.DeviceUID, nil
}

// ResetDeviceUID resets all changes to the "device_uid" field.
func (m *UserDeviceMutation) ResetDeviceUID() {
	m.device_uid = nil
}

// SetDeviceName sets the "device_name" field.
func (m *UserDeviceMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *UserDeviceMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *UserDeviceMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[userdevice.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *UserDeviceMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *UserDeviceMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, userdevice.FieldDeviceName)
}

// SetSystemName sets the "system_name" field.
func (m *UserDeviceMutation) SetSystemName(s string) {
	m.system_name = &s
}

// SystemName returns the value of the "system_name" field in the mutation.
func (m *UserDeviceMutation) SystemName() (r string, exists bool) {
	v := m.system_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemName returns the old "system_name" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldSystemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemName: %w", err)
	}
	return oldValue.SystemName, nil
}

// ClearSystemName clears the value of the "system_name" field.
func (m *UserDeviceMutation) ClearSystemName() {
	m.system_name = nil
	m.clearedFields[userdevice.FieldSystemName] = struct{}{}
}

// SystemNameCleared returns if the "system_name" field was cleared in this mutation.
func (m *UserDeviceMutation) SystemNameCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldSystemName]
	return ok
}

// ResetSystemName resets all changes to the "system_name" field.
func (m *UserDeviceMutation) ResetSystemName() {
	m.system_name = nil
	delete(m.clearedFields, userdevice.FieldSystemName)
}

// SetSystemVersion sets the "system_version" field.
func (m *UserDeviceMutation) SetSystemVersion(s string) {
	m.system_version = &s
}

// SystemVersion returns the value of the "system_version" field in the mutation.
func (m *UserDeviceMutation) SystemVersion() (r string, exists bool) {
	v := m.system_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemVersion returns the old "system_version" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldSystemVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemVersion: %w", err)
	}
	return oldValue.SystemVersion, nil
}

// ClearSystemVersion clears the value of the "system_version" field.
func (m *UserDeviceMutation) ClearSystemVersion() {
	m.system_version = nil
	m.clearedFields[userdevice.FieldSystemVersion] = struct{}{}
}

// SystemVersionCleared returns if the "system_version" field was cleared in this mutation.
func (m *UserDeviceMutation) SystemVersionCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldSystemVersion]
	return ok
}

// ResetSystemVersion resets all changes to the "system_version" field.
func (m *UserDeviceMutation) ResetSystemVersion() {
	m.system_version = nil
	delete(m.clearedFields, userdevice.FieldSystemVersion)
}

// SetAppVersion sets the "app_version" field.
func (m *UserDeviceMutation) SetAppVersion(s string) {
	m.app_version = &s
}

// AppVersion returns the value of the "app_version" field in the mutation.
func (m *UserDeviceMutation) AppVersion() (r string, exists bool) {
	v := m.app_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersion returns the old "app_version" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldAppVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersion: %w", err)
	}
	return oldValue.AppVersion, nil
}

// ClearAppVersion clears the value of the "app_version" field.
func (m *UserDeviceMutation) ClearAppVersion() {
	m.app_version = nil
	m.clearedFields[userdevice.FieldAppVersion] = struct{}{}
}

// AppVersionCleared returns if the "app_version" field was cleared in this mutation.
func (m *UserDeviceMutation) AppVersionCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldAppVersion]
	return ok
}

// ResetAppVersion resets all changes to the "app_version" field.
func (m *UserDeviceMutation) ResetAppVersion() {
	m.app_version = nil
	delete(m.clearedFields, userdevice.FieldAppVersion)
}

// SetDeviceModel sets the "device_model" field.
func (m *UserDeviceMutation) SetDeviceModel(s string) {
	m.device_model = &s
}

// DeviceModel returns the value of the "device_model" field in the mutation.
func (m *UserDeviceMutation) DeviceModel() (r string, exists bool) {
	v := m.device_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceModel returns the old "device_model" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceModel: %w", err)
	}
	return oldValue.DeviceModel, nil
}

// ClearDeviceModel clears the value of the "device_model" field.
func (m *UserDeviceMutation) ClearDeviceModel() {
	m.device_model = nil
	m.clearedFields[userdevice.FieldDeviceModel] = struct{}{}
}

// DeviceModelCleared returns if the "device_model" field was cleared in this mutation.
func (m *UserDeviceMutation) DeviceModelCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldDeviceModel]
	return ok
}

// ResetDeviceModel resets all changes to the "device_model" field.
func (m *UserDeviceMutation) ResetDeviceModel() {
	m.device_model = nil
	delete(m.clearedFields, userdevice.FieldDeviceModel)
}

// SetStatus sets the "status" field.
func (m *UserDeviceMutation) SetStatus(u userdevice.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserDeviceMutation) Status() (r userdevice.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldStatus(ctx context.Context) (v userdevice.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserDeviceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[userdevice.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserDeviceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserDeviceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, userdevice.FieldStatus)
}

// SetComments sets the "comments" field.
func (m *UserDeviceMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *UserDeviceMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *UserDeviceMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[userdevice.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *UserDeviceMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *UserDeviceMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, userdevice.FieldComments)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDeviceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDeviceMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device_uid != nil {
		fields = append(fields, userdevice.FieldDeviceUID)
	}
	if m.device_name != nil {
		fields = append(fields, userdevice.FieldDeviceName)
	}
	if m.system_name != nil {
		fields = append(fields, userdevice.FieldSystemName)
	}
	if m.system_version != nil {
		fields = append(fields, userdevice.FieldSystemVersion)
	}
	if m.app_version != nil {
		fields = append(fields, userdevice.FieldAppVersion)
	}
	if m.device_model != nil {
		fields = append(fields, userdevice.FieldDeviceModel)
	}
	if m.status != nil {
		fields = append(fields, userdevice.FieldStatus)
	}
	if m.comments != nil {
		fields = append(fields, userdevice.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.CreatedBy()
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	case userdevice.FieldUpdatedBy:
		return m.UpdatedBy()
	case userdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceUID:
		return m.DeviceUID()
	case userdevice.FieldDeviceName:
		return m.DeviceName()
	case userdevice.FieldSystemName:
		return m.SystemName()
	case userdevice.FieldSystemVersion:
		return m.SystemVersion()
	case userdevice.FieldAppVersion:
		return m.AppVersion()
	case userdevice.FieldDeviceModel:
		return m.DeviceModel()
	case userdevice.FieldStatus:
		return m.Status()
	case userdevice.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdevice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceUID:
		return m.OldDeviceUID(ctx)
	case userdevice.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case userdevice.FieldSystemName:
		return m.OldSystemName(ctx)
	case userdevice.FieldSystemVersion:
		return m.OldSystemVersion(ctx)
	case userdevice.FieldAppVersion:
		return m.OldAppVersion(ctx)
	case userdevice.FieldDeviceModel:
		return m.OldDeviceModel(ctx)
	case userdevice.FieldStatus:
		return m.OldStatus(ctx)
	case userdevice.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdevice.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceUID(v)
		return nil
	case userdevice.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case userdevice.FieldSystemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemName(v)
		return nil
	case userdevice.FieldSystemVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemVersion(v)
		return nil
	case userdevice.FieldAppVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersion(v)
		return nil
	case userdevice.FieldDeviceModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceModel(v)
		return nil
	case userdevice.FieldStatus:
		v, ok := value.(userdevice.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case userdevice.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userdevice.FieldUpdatedBy) {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.FieldCleared(userdevice.FieldUpdatedAt) {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.FieldCleared(userdevice.FieldUserID) {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.FieldCleared(userdevice.FieldDeviceName) {
		fields = append(fields, userdevice.FieldDeviceName)
	}
	if m.FieldCleared(userdevice.FieldSystemName) {
		fields = append(fields, userdevice.FieldSystemName)
	}
	if m.FieldCleared(userdevice.FieldSystemVersion) {
		fields = append(fields, userdevice.FieldSystemVersion)
	}
	if m.FieldCleared(userdevice.FieldAppVersion) {
		fields = append(fields, userdevice.FieldAppVersion)
	}
	if m.FieldCleared(userdevice.FieldDeviceModel) {
		fields = append(fields, userdevice.FieldDeviceModel)
	}
	if m.FieldCleared(userdevice.FieldStatus) {
		fields = append(fields, userdevice.FieldStatus)
	}
	if m.FieldCleared(userdevice.FieldComments) {
		fields = append(fields, userdevice.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	switch name {
	case userdevice.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userdevice.FieldUserID:
		m.ClearUserID()
		return nil
	case userdevice.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case userdevice.FieldSystemName:
		m.ClearSystemName()
		return nil
	case userdevice.FieldSystemVersion:
		m.ClearSystemVersion()
		return nil
	case userdevice.FieldAppVersion:
		m.ClearAppVersion()
		return nil
	case userdevice.FieldDeviceModel:
		m.ClearDeviceModel()
		return nil
	case userdevice.FieldStatus:
		m.ClearStatus()
		return nil
	case userdevice.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdevice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceUID:
		m.ResetDeviceUID()
		return nil
	case userdevice.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case userdevice.FieldSystemName:
		m.ResetSystemName()
		return nil
	case userdevice.FieldSystemVersion:
		m.ResetSystemVersion()
		return nil
	case userdevice.FieldAppVersion:
		m.ResetAppVersion()
		return nil
	case userdevice.FieldDeviceModel:
		m.ResetDeviceModel()
		return nil
	case userdevice.FieldStatus:
		m.ResetStatus()
		return nil
	case userdevice.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case userdevice.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// UserIdentityMutation represents an operation that mutates the UserIdentity nodes in the graph.
type UserIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	kind          *useridentity.Kind
	code          *string
	code_extend   *string
	status        *useridentity.Status
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserIdentity, error)
	predicates    []predicate.UserIdentity
}

var _ ent.Mutation = (*UserIdentityMutation)(nil)

// useridentityOption allows management of the mutation configuration using functional options.
type useridentityOption func(*UserIdentityMutation)

// newUserIdentityMutation creates new mutation for the UserIdentity entity.
func newUserIdentityMutation(c config, op Op, opts ...useridentityOption) *UserIdentityMutation {
	m := &UserIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserIdentityID sets the ID field of the mutation.
func withUserIdentityID(id int) useridentityOption {
	return func(m *UserIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserIdentity
		)
		m.oldValue = func(ctx context.Context) (*UserIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserIdentity sets the old UserIdentity of the mutation.
func withUserIdentity(node *UserIdentity) useridentityOption {
	return func(m *UserIdentityMutation) {
		m.oldValue = func(context.Context) (*UserIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserIdentity entities.
func (m *UserIdentityMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserIdentityMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserIdentityMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserIdentityMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserIdentityMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserIdentityMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserIdentityMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserIdentityMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserIdentityMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserIdentityMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserIdentityMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[useridentity.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserIdentityMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserIdentityMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, useridentity.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserIdentityMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[useridentity.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserIdentityMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, useridentity.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserIdentityMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserIdentityMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserIdentityMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserIdentityMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserIdentityMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, useridentity.FieldUserID)
}

// SetKind sets the "kind" field.
func (m *UserIdentityMutation) SetKind(u useridentity.Kind) {
	m.kind = &u
}

// Kind returns the value of the "kind" field in the mutation.
func (m *UserIdentityMutation) Kind() (r useridentity.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldKind(ctx context.Context) (v useridentity.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *UserIdentityMutation) ResetKind() {
	m.kind = nil
}

// SetCode sets the "code" field.
func (m *UserIdentityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *UserIdentityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *UserIdentityMutation) ClearCode() {
	m.code = nil
	m.clearedFields[useridentity.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *UserIdentityMutation) CodeCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *UserIdentityMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, useridentity.FieldCode)
}

// SetCodeExtend sets the "code_extend" field.
func (m *UserIdentityMutation) SetCodeExtend(s string) {
	m.code_extend = &s
}

// CodeExtend returns the value of the "code_extend" field in the mutation.
func (m *UserIdentityMutation) CodeExtend() (r string, exists bool) {
	v := m.code_extend
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeExtend returns the old "code_extend" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCodeExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeExtend: %w", err)
	}
	return oldValue.CodeExtend, nil
}

// ClearCodeExtend clears the value of the "code_extend" field.
func (m *UserIdentityMutation) ClearCodeExtend() {
	m.code_extend = nil
	m.clearedFields[useridentity.FieldCodeExtend] = struct{}{}
}

// CodeExtendCleared returns if the "code_extend" field was cleared in this mutation.
func (m *UserIdentityMutation) CodeExtendCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldCodeExtend]
	return ok
}

// ResetCodeExtend resets all changes to the "code_extend" field.
func (m *UserIdentityMutation) ResetCodeExtend() {
	m.code_extend = nil
	delete(m.clearedFields, useridentity.FieldCodeExtend)
}

// SetStatus sets the "status" field.
func (m *UserIdentityMutation) SetStatus(u useridentity.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserIdentityMutation) Status() (r useridentity.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldStatus(ctx context.Context) (v useridentity.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserIdentityMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[useridentity.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserIdentityMutation) StatusCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserIdentityMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, useridentity.FieldStatus)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserIdentityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserIdentityMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserIdentityMutation builder.
func (m *UserIdentityMutation) Where(ps ...predicate.UserIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserIdentity).
func (m *UserIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserIdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, useridentity.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, useridentity.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.kind != nil {
		fields = append(fields, useridentity.FieldKind)
	}
	if m.code != nil {
		fields = append(fields, useridentity.FieldCode)
	}
	if m.code_extend != nil {
		fields = append(fields, useridentity.FieldCodeExtend)
	}
	if m.status != nil {
		fields = append(fields, useridentity.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.CreatedBy()
	case useridentity.FieldCreatedAt:
		return m.CreatedAt()
	case useridentity.FieldUpdatedBy:
		return m.UpdatedBy()
	case useridentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case useridentity.FieldUserID:
		return m.UserID()
	case useridentity.FieldKind:
		return m.Kind()
	case useridentity.FieldCode:
		return m.Code()
	case useridentity.FieldCodeExtend:
		return m.CodeExtend()
	case useridentity.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case useridentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useridentity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case useridentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useridentity.FieldUserID:
		return m.OldUserID(ctx)
	case useridentity.FieldKind:
		return m.OldKind(ctx)
	case useridentity.FieldCode:
		return m.OldCode(ctx)
	case useridentity.FieldCodeExtend:
		return m.OldCodeExtend(ctx)
	case useridentity.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case useridentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useridentity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case useridentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useridentity.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useridentity.FieldKind:
		v, ok := value.(useridentity.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case useridentity.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case useridentity.FieldCodeExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeExtend(v)
		return nil
	case useridentity.FieldStatus:
		v, ok := value.(useridentity.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserIdentityMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, useridentity.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserIdentityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.AddedCreatedBy()
	case useridentity.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case useridentity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridentity.FieldUpdatedBy) {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	if m.FieldCleared(useridentity.FieldUpdatedAt) {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	if m.FieldCleared(useridentity.FieldUserID) {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.FieldCleared(useridentity.FieldCode) {
		fields = append(fields, useridentity.FieldCode)
	}
	if m.FieldCleared(useridentity.FieldCodeExtend) {
		fields = append(fields, useridentity.FieldCodeExtend)
	}
	if m.FieldCleared(useridentity.FieldStatus) {
		fields = append(fields, useridentity.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIdentityMutation) ClearField(name string) error {
	switch name {
	case useridentity.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case useridentity.FieldUserID:
		m.ClearUserID()
		return nil
	case useridentity.FieldCode:
		m.ClearCode()
		return nil
	case useridentity.FieldCodeExtend:
		m.ClearCodeExtend()
		return nil
	case useridentity.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserIdentityMutation) ResetField(name string) error {
	switch name {
	case useridentity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case useridentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useridentity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useridentity.FieldUserID:
		m.ResetUserID()
		return nil
	case useridentity.FieldKind:
		m.ResetKind()
		return nil
	case useridentity.FieldCode:
		m.ResetCode()
		return nil
	case useridentity.FieldCodeExtend:
		m.ResetCodeExtend()
		return nil
	case useridentity.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case useridentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserIdentityMutation) ClearEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserIdentityMutation) ResetEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity edge %s", name)
}

// UserLoginProfileMutation represents an operation that mutates the UserLoginProfile nodes in the graph.
type UserLoginProfileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_by     *int
	addcreated_by  *int
	created_at     *time.Time
	updated_by     *int
	addupdated_by  *int
	updated_at     *time.Time
	last_login_ip  *string
	last_login_at  *time.Time
	can_login      *bool
	set_kind       *userloginprofile.SetKind
	password_reset *bool
	verify_device  *bool
	mfa_enabled    *bool
	mfa_secret     *string
	mfa_status     *userloginprofile.MfaStatus
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserLoginProfile, error)
	predicates     []predicate.UserLoginProfile
}

var _ ent.Mutation = (*UserLoginProfileMutation)(nil)

// userloginprofileOption allows management of the mutation configuration using functional options.
type userloginprofileOption func(*UserLoginProfileMutation)

// newUserLoginProfileMutation creates new mutation for the UserLoginProfile entity.
func newUserLoginProfileMutation(c config, op Op, opts ...userloginprofileOption) *UserLoginProfileMutation {
	m := &UserLoginProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginProfileID sets the ID field of the mutation.
func withUserLoginProfileID(id int) userloginprofileOption {
	return func(m *UserLoginProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginProfile
		)
		m.oldValue = func(ctx context.Context) (*UserLoginProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginProfile sets the old UserLoginProfile of the mutation.
func withUserLoginProfile(node *UserLoginProfile) userloginprofileOption {
	return func(m *UserLoginProfileMutation) {
		m.oldValue = func(context.Context) (*UserLoginProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLoginProfile entities.
func (m *UserLoginProfileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLoginProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserLoginProfileMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserLoginProfileMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserLoginProfileMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserLoginProfileMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserLoginProfileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserLoginProfileMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserLoginProfileMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserLoginProfileMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserLoginProfileMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserLoginProfileMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userloginprofile.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserLoginProfileMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userloginprofile.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserLoginProfileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userloginprofile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userloginprofile.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserLoginProfileMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLoginProfileMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserLoginProfileMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userloginprofile.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLoginProfileMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userloginprofile.FieldUserID)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserLoginProfileMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserLoginProfileMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserLoginProfileMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[userloginprofile.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserLoginProfileMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserLoginProfileMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, userloginprofile.FieldLastLoginIP)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserLoginProfileMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserLoginProfileMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserLoginProfileMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[userloginprofile.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserLoginProfileMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserLoginProfileMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, userloginprofile.FieldLastLoginAt)
}

// SetCanLogin sets the "can_login" field.
func (m *UserLoginProfileMutation) SetCanLogin(b bool) {
	m.can_login = &b
}

// CanLogin returns the value of the "can_login" field in the mutation.
func (m *UserLoginProfileMutation) CanLogin() (r bool, exists bool) {
	v := m.can_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCanLogin returns the old "can_login" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCanLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanLogin: %w", err)
	}
	return oldValue.CanLogin, nil
}

// ClearCanLogin clears the value of the "can_login" field.
func (m *UserLoginProfileMutation) ClearCanLogin() {
	m.can_login = nil
	m.clearedFields[userloginprofile.FieldCanLogin] = struct{}{}
}

// CanLoginCleared returns if the "can_login" field was cleared in this mutation.
func (m *UserLoginProfileMutation) CanLoginCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldCanLogin]
	return ok
}

// ResetCanLogin resets all changes to the "can_login" field.
func (m *UserLoginProfileMutation) ResetCanLogin() {
	m.can_login = nil
	delete(m.clearedFields, userloginprofile.FieldCanLogin)
}

// SetSetKind sets the "set_kind" field.
func (m *UserLoginProfileMutation) SetSetKind(uk userloginprofile.SetKind) {
	m.set_kind = &uk
}

// SetKind returns the value of the "set_kind" field in the mutation.
func (m *UserLoginProfileMutation) SetKind() (r userloginprofile.SetKind, exists bool) {
	v := m.set_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldSetKind returns the old "set_kind" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldSetKind(ctx context.Context) (v userloginprofile.SetKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetKind: %w", err)
	}
	return oldValue.SetKind, nil
}

// ResetSetKind resets all changes to the "set_kind" field.
func (m *UserLoginProfileMutation) ResetSetKind() {
	m.set_kind = nil
}

// SetPasswordReset sets the "password_reset" field.
func (m *UserLoginProfileMutation) SetPasswordReset(b bool) {
	m.password_reset = &b
}

// PasswordReset returns the value of the "password_reset" field in the mutation.
func (m *UserLoginProfileMutation) PasswordReset() (r bool, exists bool) {
	v := m.password_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordReset returns the old "password_reset" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldPasswordReset(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordReset: %w", err)
	}
	return oldValue.PasswordReset, nil
}

// ClearPasswordReset clears the value of the "password_reset" field.
func (m *UserLoginProfileMutation) ClearPasswordReset() {
	m.password_reset = nil
	m.clearedFields[userloginprofile.FieldPasswordReset] = struct{}{}
}

// PasswordResetCleared returns if the "password_reset" field was cleared in this mutation.
func (m *UserLoginProfileMutation) PasswordResetCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldPasswordReset]
	return ok
}

// ResetPasswordReset resets all changes to the "password_reset" field.
func (m *UserLoginProfileMutation) ResetPasswordReset() {
	m.password_reset = nil
	delete(m.clearedFields, userloginprofile.FieldPasswordReset)
}

// SetVerifyDevice sets the "verify_device" field.
func (m *UserLoginProfileMutation) SetVerifyDevice(b bool) {
	m.verify_device = &b
}

// VerifyDevice returns the value of the "verify_device" field in the mutation.
func (m *UserLoginProfileMutation) VerifyDevice() (r bool, exists bool) {
	v := m.verify_device
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyDevice returns the old "verify_device" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldVerifyDevice(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyDevice: %w", err)
	}
	return oldValue.VerifyDevice, nil
}

// ResetVerifyDevice resets all changes to the "verify_device" field.
func (m *UserLoginProfileMutation) ResetVerifyDevice() {
	m.verify_device = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *UserLoginProfileMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *UserLoginProfileMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ClearMfaEnabled clears the value of the "mfa_enabled" field.
func (m *UserLoginProfileMutation) ClearMfaEnabled() {
	m.mfa_enabled = nil
	m.clearedFields[userloginprofile.FieldMfaEnabled] = struct{}{}
}

// MfaEnabledCleared returns if the "mfa_enabled" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaEnabledCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaEnabled]
	return ok
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *UserLoginProfileMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
	delete(m.clearedFields, userloginprofile.FieldMfaEnabled)
}

// SetMfaSecret sets the "mfa_secret" field.
func (m *UserLoginProfileMutation) SetMfaSecret(s string) {
	m.mfa_secret = &s
}

// MfaSecret returns the value of the "mfa_secret" field in the mutation.
func (m *UserLoginProfileMutation) MfaSecret() (r string, exists bool) {
	v := m.mfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaSecret returns the old "mfa_secret" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaSecret: %w", err)
	}
	return oldValue.MfaSecret, nil
}

// ClearMfaSecret clears the value of the "mfa_secret" field.
func (m *UserLoginProfileMutation) ClearMfaSecret() {
	m.mfa_secret = nil
	m.clearedFields[userloginprofile.FieldMfaSecret] = struct{}{}
}

// MfaSecretCleared returns if the "mfa_secret" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaSecretCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaSecret]
	return ok
}

// ResetMfaSecret resets all changes to the "mfa_secret" field.
func (m *UserLoginProfileMutation) ResetMfaSecret() {
	m.mfa_secret = nil
	delete(m.clearedFields, userloginprofile.FieldMfaSecret)
}

// SetMfaStatus sets the "mfa_status" field.
func (m *UserLoginProfileMutation) SetMfaStatus(us userloginprofile.MfaStatus) {
	m.mfa_status = &us
}

// MfaStatus returns the value of the "mfa_status" field in the mutation.
func (m *UserLoginProfileMutation) MfaStatus() (r userloginprofile.MfaStatus, exists bool) {
	v := m.mfa_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaStatus returns the old "mfa_status" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaStatus(ctx context.Context) (v userloginprofile.MfaStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaStatus: %w", err)
	}
	return oldValue.MfaStatus, nil
}

// ClearMfaStatus clears the value of the "mfa_status" field.
func (m *UserLoginProfileMutation) ClearMfaStatus() {
	m.mfa_status = nil
	m.clearedFields[userloginprofile.FieldMfaStatus] = struct{}{}
}

// MfaStatusCleared returns if the "mfa_status" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaStatusCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaStatus]
	return ok
}

// ResetMfaStatus resets all changes to the "mfa_status" field.
func (m *UserLoginProfileMutation) ResetMfaStatus() {
	m.mfa_status = nil
	delete(m.clearedFields, userloginprofile.FieldMfaStatus)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLoginProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLoginProfileMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserLoginProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLoginProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserLoginProfileMutation builder.
func (m *UserLoginProfileMutation) Where(ps ...predicate.UserLoginProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLoginProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLoginProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLoginProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLoginProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLoginProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLoginProfile).
func (m *UserLoginProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginProfileMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, userloginprofile.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userloginprofile.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userloginprofile.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userloginprofile.FieldUserID)
	}
	if m.last_login_ip != nil {
		fields = append(fields, userloginprofile.FieldLastLoginIP)
	}
	if m.last_login_at != nil {
		fields = append(fields, userloginprofile.FieldLastLoginAt)
	}
	if m.can_login != nil {
		fields = append(fields, userloginprofile.FieldCanLogin)
	}
	if m.set_kind != nil {
		fields = append(fields, userloginprofile.FieldSetKind)
	}
	if m.password_reset != nil {
		fields = append(fields, userloginprofile.FieldPasswordReset)
	}
	if m.verify_device != nil {
		fields = append(fields, userloginprofile.FieldVerifyDevice)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, userloginprofile.FieldMfaEnabled)
	}
	if m.mfa_secret != nil {
		fields = append(fields, userloginprofile.FieldMfaSecret)
	}
	if m.mfa_status != nil {
		fields = append(fields, userloginprofile.FieldMfaStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.CreatedBy()
	case userloginprofile.FieldCreatedAt:
		return m.CreatedAt()
	case userloginprofile.FieldUpdatedBy:
		return m.UpdatedBy()
	case userloginprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case userloginprofile.FieldUserID:
		return m.UserID()
	case userloginprofile.FieldLastLoginIP:
		return m.LastLoginIP()
	case userloginprofile.FieldLastLoginAt:
		return m.LastLoginAt()
	case userloginprofile.FieldCanLogin:
		return m.CanLogin()
	case userloginprofile.FieldSetKind:
		return m.SetKind()
	case userloginprofile.FieldPasswordReset:
		return m.PasswordReset()
	case userloginprofile.FieldVerifyDevice:
		return m.VerifyDevice()
	case userloginprofile.FieldMfaEnabled:
		return m.MfaEnabled()
	case userloginprofile.FieldMfaSecret:
		return m.MfaSecret()
	case userloginprofile.FieldMfaStatus:
		return m.MfaStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userloginprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userloginprofile.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userloginprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userloginprofile.FieldUserID:
		return m.OldUserID(ctx)
	case userloginprofile.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case userloginprofile.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case userloginprofile.FieldCanLogin:
		return m.OldCanLogin(ctx)
	case userloginprofile.FieldSetKind:
		return m.OldSetKind(ctx)
	case userloginprofile.FieldPasswordReset:
		return m.OldPasswordReset(ctx)
	case userloginprofile.FieldVerifyDevice:
		return m.OldVerifyDevice(ctx)
	case userloginprofile.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case userloginprofile.FieldMfaSecret:
		return m.OldMfaSecret(ctx)
	case userloginprofile.FieldMfaStatus:
		return m.OldMfaStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userloginprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userloginprofile.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userloginprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userloginprofile.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userloginprofile.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case userloginprofile.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case userloginprofile.FieldCanLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanLogin(v)
		return nil
	case userloginprofile.FieldSetKind:
		v, ok := value.(userloginprofile.SetKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetKind(v)
		return nil
	case userloginprofile.FieldPasswordReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordReset(v)
		return nil
	case userloginprofile.FieldVerifyDevice:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyDevice(v)
		return nil
	case userloginprofile.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case userloginprofile.FieldMfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaSecret(v)
		return nil
	case userloginprofile.FieldMfaStatus:
		v, ok := value.(userloginprofile.MfaStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginProfileMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userloginprofile.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userloginprofile.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userloginprofile.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginprofile.FieldUpdatedBy) {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	if m.FieldCleared(userloginprofile.FieldUpdatedAt) {
		fields = append(fields, userloginprofile.FieldUpdatedAt)
	}
	if m.FieldCleared(userloginprofile.FieldUserID) {
		fields = append(fields, userloginprofile.FieldUserID)
	}
	if m.FieldCleared(userloginprofile.FieldLastLoginIP) {
		fields = append(fields, userloginprofile.FieldLastLoginIP)
	}
	if m.FieldCleared(userloginprofile.FieldLastLoginAt) {
		fields = append(fields, userloginprofile.FieldLastLoginAt)
	}
	if m.FieldCleared(userloginprofile.FieldCanLogin) {
		fields = append(fields, userloginprofile.FieldCanLogin)
	}
	if m.FieldCleared(userloginprofile.FieldPasswordReset) {
		fields = append(fields, userloginprofile.FieldPasswordReset)
	}
	if m.FieldCleared(userloginprofile.FieldMfaEnabled) {
		fields = append(fields, userloginprofile.FieldMfaEnabled)
	}
	if m.FieldCleared(userloginprofile.FieldMfaSecret) {
		fields = append(fields, userloginprofile.FieldMfaSecret)
	}
	if m.FieldCleared(userloginprofile.FieldMfaStatus) {
		fields = append(fields, userloginprofile.FieldMfaStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginProfileMutation) ClearField(name string) error {
	switch name {
	case userloginprofile.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userloginprofile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userloginprofile.FieldUserID:
		m.ClearUserID()
		return nil
	case userloginprofile.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case userloginprofile.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case userloginprofile.FieldCanLogin:
		m.ClearCanLogin()
		return nil
	case userloginprofile.FieldPasswordReset:
		m.ClearPasswordReset()
		return nil
	case userloginprofile.FieldMfaEnabled:
		m.ClearMfaEnabled()
		return nil
	case userloginprofile.FieldMfaSecret:
		m.ClearMfaSecret()
		return nil
	case userloginprofile.FieldMfaStatus:
		m.ClearMfaStatus()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginProfileMutation) ResetField(name string) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userloginprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userloginprofile.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userloginprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userloginprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case userloginprofile.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case userloginprofile.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case userloginprofile.FieldCanLogin:
		m.ResetCanLogin()
		return nil
	case userloginprofile.FieldSetKind:
		m.ResetSetKind()
		return nil
	case userloginprofile.FieldPasswordReset:
		m.ResetPasswordReset()
		return nil
	case userloginprofile.FieldVerifyDevice:
		m.ResetVerifyDevice()
		return nil
	case userloginprofile.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case userloginprofile.FieldMfaSecret:
		m.ResetMfaSecret()
		return nil
	case userloginprofile.FieldMfaStatus:
		m.ResetMfaStatus()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userloginprofile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userloginprofile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginprofile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginProfileMutation) ClearEdge(name string) error {
	switch name {
	case userloginprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginProfileMutation) ResetEdge(name string) error {
	switch name {
	case userloginprofile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile edge %s", name)
}

// UserPasswordMutation represents an operation that mutates the UserPassword nodes in the graph.
type UserPasswordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	scene         *userpassword.Scene
	password      *string
	salt          *string
	status        *userpassword.Status
	memo          *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserPassword, error)
	predicates    []predicate.UserPassword
}

var _ ent.Mutation = (*UserPasswordMutation)(nil)

// userpasswordOption allows management of the mutation configuration using functional options.
type userpasswordOption func(*UserPasswordMutation)

// newUserPasswordMutation creates new mutation for the UserPassword entity.
func newUserPasswordMutation(c config, op Op, opts ...userpasswordOption) *UserPasswordMutation {
	m := &UserPasswordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPasswordID sets the ID field of the mutation.
func withUserPasswordID(id int) userpasswordOption {
	return func(m *UserPasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPassword
		)
		m.oldValue = func(ctx context.Context) (*UserPassword, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPassword.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPassword sets the old UserPassword of the mutation.
func withUserPassword(node *UserPassword) userpasswordOption {
	return func(m *UserPasswordMutation) {
		m.oldValue = func(context.Context) (*UserPassword, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPassword entities.
func (m *UserPasswordMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPasswordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPasswordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPassword.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserPasswordMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserPasswordMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserPasswordMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserPasswordMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserPasswordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserPasswordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserPasswordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserPasswordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserPasswordMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserPasswordMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserPasswordMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserPasswordMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserPasswordMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userpassword.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserPasswordMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserPasswordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userpassword.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserPasswordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserPasswordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserPasswordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userpassword.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserPasswordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserPasswordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userpassword.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserPasswordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPasswordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserPasswordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userpassword.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserPasswordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPasswordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userpassword.FieldUserID)
}

// SetScene sets the "scene" field.
func (m *UserPasswordMutation) SetScene(u userpassword.Scene) {
	m.scene = &u
}

// Scene returns the value of the "scene" field in the mutation.
func (m *UserPasswordMutation) Scene() (r userpassword.Scene, exists bool) {
	v := m.scene
	if v == nil {
		return
	}
	return *v, true
}

// OldScene returns the old "scene" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldScene(ctx context.Context) (v userpassword.Scene, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScene is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScene requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScene: %w", err)
	}
	return oldValue.Scene, nil
}

// ClearScene clears the value of the "scene" field.
func (m *UserPasswordMutation) ClearScene() {
	m.scene = nil
	m.clearedFields[userpassword.FieldScene] = struct{}{}
}

// SceneCleared returns if the "scene" field was cleared in this mutation.
func (m *UserPasswordMutation) SceneCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldScene]
	return ok
}

// ResetScene resets all changes to the "scene" field.
func (m *UserPasswordMutation) ResetScene() {
	m.scene = nil
	delete(m.clearedFields, userpassword.FieldScene)
}

// SetPassword sets the "password" field.
func (m *UserPasswordMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserPasswordMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserPasswordMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[userpassword.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserPasswordMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserPasswordMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, userpassword.FieldPassword)
}

// SetSalt sets the "salt" field.
func (m *UserPasswordMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserPasswordMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserPasswordMutation) ResetSalt() {
	m.salt = nil
}

// SetStatus sets the "status" field.
func (m *UserPasswordMutation) SetStatus(u userpassword.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserPasswordMutation) Status() (r userpassword.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldStatus(ctx context.Context) (v userpassword.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserPasswordMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[userpassword.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserPasswordMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserPasswordMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, userpassword.FieldStatus)
}

// SetMemo sets the "memo" field.
func (m *UserPasswordMutation) SetMemo(s string) {
	m.memo = &s
}

// Memo returns the value of the "memo" field in the mutation.
func (m *UserPasswordMutation) Memo() (r string, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old "memo" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldMemo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// ClearMemo clears the value of the "memo" field.
func (m *UserPasswordMutation) ClearMemo() {
	m.memo = nil
	m.clearedFields[userpassword.FieldMemo] = struct{}{}
}

// MemoCleared returns if the "memo" field was cleared in this mutation.
func (m *UserPasswordMutation) MemoCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldMemo]
	return ok
}

// ResetMemo resets all changes to the "memo" field.
func (m *UserPasswordMutation) ResetMemo() {
	m.memo = nil
	delete(m.clearedFields, userpassword.FieldMemo)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPasswordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPasswordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPasswordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPasswordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserPasswordMutation builder.
func (m *UserPasswordMutation) Where(ps ...predicate.UserPassword) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPassword, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPassword).
func (m *UserPasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPasswordMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, userpassword.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userpassword.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userpassword.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.scene != nil {
		fields = append(fields, userpassword.FieldScene)
	}
	if m.password != nil {
		fields = append(fields, userpassword.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, userpassword.FieldSalt)
	}
	if m.status != nil {
		fields = append(fields, userpassword.FieldStatus)
	}
	if m.memo != nil {
		fields = append(fields, userpassword.FieldMemo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.CreatedBy()
	case userpassword.FieldCreatedAt:
		return m.CreatedAt()
	case userpassword.FieldUpdatedBy:
		return m.UpdatedBy()
	case userpassword.FieldUpdatedAt:
		return m.UpdatedAt()
	case userpassword.FieldUserID:
		return m.UserID()
	case userpassword.FieldScene:
		return m.Scene()
	case userpassword.FieldPassword:
		return m.Password()
	case userpassword.FieldSalt:
		return m.Salt()
	case userpassword.FieldStatus:
		return m.Status()
	case userpassword.FieldMemo:
		return m.Memo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userpassword.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userpassword.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userpassword.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userpassword.FieldUserID:
		return m.OldUserID(ctx)
	case userpassword.FieldScene:
		return m.OldScene(ctx)
	case userpassword.FieldPassword:
		return m.OldPassword(ctx)
	case userpassword.FieldSalt:
		return m.OldSalt(ctx)
	case userpassword.FieldStatus:
		return m.OldStatus(ctx)
	case userpassword.FieldMemo:
		return m.OldMemo(ctx)
	}
	return nil, fmt.Errorf("unknown UserPassword field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userpassword.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userpassword.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userpassword.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userpassword.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpassword.FieldScene:
		v, ok := value.(userpassword.Scene)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScene(v)
		return nil
	case userpassword.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case userpassword.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case userpassword.FieldStatus:
		v, ok := value.(userpassword.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case userpassword.FieldMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPasswordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userpassword.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPasswordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userpassword.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userpassword.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPasswordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpassword.FieldUpdatedBy) {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	if m.FieldCleared(userpassword.FieldUpdatedAt) {
		fields = append(fields, userpassword.FieldUpdatedAt)
	}
	if m.FieldCleared(userpassword.FieldUserID) {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.FieldCleared(userpassword.FieldScene) {
		fields = append(fields, userpassword.FieldScene)
	}
	if m.FieldCleared(userpassword.FieldPassword) {
		fields = append(fields, userpassword.FieldPassword)
	}
	if m.FieldCleared(userpassword.FieldStatus) {
		fields = append(fields, userpassword.FieldStatus)
	}
	if m.FieldCleared(userpassword.FieldMemo) {
		fields = append(fields, userpassword.FieldMemo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPasswordMutation) ClearField(name string) error {
	switch name {
	case userpassword.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userpassword.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userpassword.FieldUserID:
		m.ClearUserID()
		return nil
	case userpassword.FieldScene:
		m.ClearScene()
		return nil
	case userpassword.FieldPassword:
		m.ClearPassword()
		return nil
	case userpassword.FieldStatus:
		m.ClearStatus()
		return nil
	case userpassword.FieldMemo:
		m.ClearMemo()
		return nil
	}
	return fmt.Errorf("unknown UserPassword nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPasswordMutation) ResetField(name string) error {
	switch name {
	case userpassword.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userpassword.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userpassword.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userpassword.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userpassword.FieldUserID:
		m.ResetUserID()
		return nil
	case userpassword.FieldScene:
		m.ResetScene()
		return nil
	case userpassword.FieldPassword:
		m.ResetPassword()
		return nil
	case userpassword.FieldSalt:
		m.ResetSalt()
		return nil
	case userpassword.FieldStatus:
		m.ResetStatus()
		return nil
	case userpassword.FieldMemo:
		m.ResetMemo()
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userpassword.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPasswordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpassword.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPasswordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userpassword.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPasswordMutation) EdgeCleared(name string) bool {
	switch name {
	case userpassword.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPasswordMutation) ClearEdge(name string) error {
	switch name {
	case userpassword.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserPassword unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPasswordMutation) ResetEdge(name string) error {
	switch name {
	case userpassword.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserPassword edge %s", name)
}
