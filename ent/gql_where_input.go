// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/woocoos/adminx/ent/app"
	"github.com/woocoos/adminx/ent/appmenu"
	"github.com/woocoos/adminx/ent/apppermission"
	"github.com/woocoos/adminx/ent/organization"
	"github.com/woocoos/adminx/ent/organizationuser"
	"github.com/woocoos/adminx/ent/predicate"
	"github.com/woocoos/adminx/ent/user"
	"github.com/woocoos/adminx/ent/userdevice"
	"github.com/woocoos/adminx/ent/useridentity"
	"github.com/woocoos/adminx/ent/userloginprofile"
	"github.com/woocoos/adminx/ent/userpassword"
)

// AppWhereInput represents a where input for filtering App queries.
type AppWhereInput struct {
	Predicates []predicate.App  `json:"-"`
	Not        *AppWhereInput   `json:"not,omitempty"`
	Or         []*AppWhereInput `json:"or,omitempty"`
	And        []*AppWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *app.Kind  `json:"kind,omitempty"`
	KindNEQ   *app.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []app.Kind `json:"kindIn,omitempty"`
	KindNotIn []app.Kind `json:"kindNotIn,omitempty"`

	// "redirect_uri" field predicates.
	RedirectURI             *string  `json:"redirectURI,omitempty"`
	RedirectURINEQ          *string  `json:"redirectURINEQ,omitempty"`
	RedirectURIIn           []string `json:"redirectURIIn,omitempty"`
	RedirectURINotIn        []string `json:"redirectURINotIn,omitempty"`
	RedirectURIGT           *string  `json:"redirectURIGT,omitempty"`
	RedirectURIGTE          *string  `json:"redirectURIGTE,omitempty"`
	RedirectURILT           *string  `json:"redirectURILT,omitempty"`
	RedirectURILTE          *string  `json:"redirectURILTE,omitempty"`
	RedirectURIContains     *string  `json:"redirectURIContains,omitempty"`
	RedirectURIHasPrefix    *string  `json:"redirectURIHasPrefix,omitempty"`
	RedirectURIHasSuffix    *string  `json:"redirectURIHasSuffix,omitempty"`
	RedirectURIIsNil        bool     `json:"redirectURIIsNil,omitempty"`
	RedirectURINotNil       bool     `json:"redirectURINotNil,omitempty"`
	RedirectURIEqualFold    *string  `json:"redirectURIEqualFold,omitempty"`
	RedirectURIContainsFold *string  `json:"redirectURIContainsFold,omitempty"`

	// "app_key" field predicates.
	AppKey             *string  `json:"appKey,omitempty"`
	AppKeyNEQ          *string  `json:"appKeyNEQ,omitempty"`
	AppKeyIn           []string `json:"appKeyIn,omitempty"`
	AppKeyNotIn        []string `json:"appKeyNotIn,omitempty"`
	AppKeyGT           *string  `json:"appKeyGT,omitempty"`
	AppKeyGTE          *string  `json:"appKeyGTE,omitempty"`
	AppKeyLT           *string  `json:"appKeyLT,omitempty"`
	AppKeyLTE          *string  `json:"appKeyLTE,omitempty"`
	AppKeyContains     *string  `json:"appKeyContains,omitempty"`
	AppKeyHasPrefix    *string  `json:"appKeyHasPrefix,omitempty"`
	AppKeyHasSuffix    *string  `json:"appKeyHasSuffix,omitempty"`
	AppKeyIsNil        bool     `json:"appKeyIsNil,omitempty"`
	AppKeyNotNil       bool     `json:"appKeyNotNil,omitempty"`
	AppKeyEqualFold    *string  `json:"appKeyEqualFold,omitempty"`
	AppKeyContainsFold *string  `json:"appKeyContainsFold,omitempty"`

	// "app_secret" field predicates.
	AppSecret             *string  `json:"appSecret,omitempty"`
	AppSecretNEQ          *string  `json:"appSecretNEQ,omitempty"`
	AppSecretIn           []string `json:"appSecretIn,omitempty"`
	AppSecretNotIn        []string `json:"appSecretNotIn,omitempty"`
	AppSecretGT           *string  `json:"appSecretGT,omitempty"`
	AppSecretGTE          *string  `json:"appSecretGTE,omitempty"`
	AppSecretLT           *string  `json:"appSecretLT,omitempty"`
	AppSecretLTE          *string  `json:"appSecretLTE,omitempty"`
	AppSecretContains     *string  `json:"appSecretContains,omitempty"`
	AppSecretHasPrefix    *string  `json:"appSecretHasPrefix,omitempty"`
	AppSecretHasSuffix    *string  `json:"appSecretHasSuffix,omitempty"`
	AppSecretIsNil        bool     `json:"appSecretIsNil,omitempty"`
	AppSecretNotNil       bool     `json:"appSecretNotNil,omitempty"`
	AppSecretEqualFold    *string  `json:"appSecretEqualFold,omitempty"`
	AppSecretContainsFold *string  `json:"appSecretContainsFold,omitempty"`

	// "scopes" field predicates.
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNEQ          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGT           *string  `json:"scopesGT,omitempty"`
	ScopesGTE          *string  `json:"scopesGTE,omitempty"`
	ScopesLT           *string  `json:"scopesLT,omitempty"`
	ScopesLTE          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesIsNil        bool     `json:"scopesIsNil,omitempty"`
	ScopesNotNil       bool     `json:"scopesNotNil,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`

	// "token_validity" field predicates.
	TokenValidity       *int32  `json:"tokenValidity,omitempty"`
	TokenValidityNEQ    *int32  `json:"tokenValidityNEQ,omitempty"`
	TokenValidityIn     []int32 `json:"tokenValidityIn,omitempty"`
	TokenValidityNotIn  []int32 `json:"tokenValidityNotIn,omitempty"`
	TokenValidityGT     *int32  `json:"tokenValidityGT,omitempty"`
	TokenValidityGTE    *int32  `json:"tokenValidityGTE,omitempty"`
	TokenValidityLT     *int32  `json:"tokenValidityLT,omitempty"`
	TokenValidityLTE    *int32  `json:"tokenValidityLTE,omitempty"`
	TokenValidityIsNil  bool    `json:"tokenValidityIsNil,omitempty"`
	TokenValidityNotNil bool    `json:"tokenValidityNotNil,omitempty"`

	// "refresh_token_validity" field predicates.
	RefreshTokenValidity       *int32  `json:"refreshTokenValidity,omitempty"`
	RefreshTokenValidityNEQ    *int32  `json:"refreshTokenValidityNEQ,omitempty"`
	RefreshTokenValidityIn     []int32 `json:"refreshTokenValidityIn,omitempty"`
	RefreshTokenValidityNotIn  []int32 `json:"refreshTokenValidityNotIn,omitempty"`
	RefreshTokenValidityGT     *int32  `json:"refreshTokenValidityGT,omitempty"`
	RefreshTokenValidityGTE    *int32  `json:"refreshTokenValidityGTE,omitempty"`
	RefreshTokenValidityLT     *int32  `json:"refreshTokenValidityLT,omitempty"`
	RefreshTokenValidityLTE    *int32  `json:"refreshTokenValidityLTE,omitempty"`
	RefreshTokenValidityIsNil  bool    `json:"refreshTokenValidityIsNil,omitempty"`
	RefreshTokenValidityNotNil bool    `json:"refreshTokenValidityNotNil,omitempty"`

	// "logo" field predicates.
	Logo             *string  `json:"logo,omitempty"`
	LogoNEQ          *string  `json:"logoNEQ,omitempty"`
	LogoIn           []string `json:"logoIn,omitempty"`
	LogoNotIn        []string `json:"logoNotIn,omitempty"`
	LogoGT           *string  `json:"logoGT,omitempty"`
	LogoGTE          *string  `json:"logoGTE,omitempty"`
	LogoLT           *string  `json:"logoLT,omitempty"`
	LogoLTE          *string  `json:"logoLTE,omitempty"`
	LogoContains     *string  `json:"logoContains,omitempty"`
	LogoHasPrefix    *string  `json:"logoHasPrefix,omitempty"`
	LogoHasSuffix    *string  `json:"logoHasSuffix,omitempty"`
	LogoIsNil        bool     `json:"logoIsNil,omitempty"`
	LogoNotNil       bool     `json:"logoNotNil,omitempty"`
	LogoEqualFold    *string  `json:"logoEqualFold,omitempty"`
	LogoContainsFold *string  `json:"logoContainsFold,omitempty"`

	// "comments" field predicates.
	Comments             *string  `json:"comments,omitempty"`
	CommentsNEQ          *string  `json:"commentsNEQ,omitempty"`
	CommentsIn           []string `json:"commentsIn,omitempty"`
	CommentsNotIn        []string `json:"commentsNotIn,omitempty"`
	CommentsGT           *string  `json:"commentsGT,omitempty"`
	CommentsGTE          *string  `json:"commentsGTE,omitempty"`
	CommentsLT           *string  `json:"commentsLT,omitempty"`
	CommentsLTE          *string  `json:"commentsLTE,omitempty"`
	CommentsContains     *string  `json:"commentsContains,omitempty"`
	CommentsHasPrefix    *string  `json:"commentsHasPrefix,omitempty"`
	CommentsHasSuffix    *string  `json:"commentsHasSuffix,omitempty"`
	CommentsIsNil        bool     `json:"commentsIsNil,omitempty"`
	CommentsNotNil       bool     `json:"commentsNotNil,omitempty"`
	CommentsEqualFold    *string  `json:"commentsEqualFold,omitempty"`
	CommentsContainsFold *string  `json:"commentsContainsFold,omitempty"`

	// "status" field predicates.
	Status       *app.Status  `json:"status,omitempty"`
	StatusNEQ    *app.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []app.Status `json:"statusIn,omitempty"`
	StatusNotIn  []app.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool         `json:"statusIsNil,omitempty"`
	StatusNotNil bool         `json:"statusNotNil,omitempty"`

	// "menus" edge predicates.
	HasMenus     *bool                `json:"hasMenus,omitempty"`
	HasMenusWith []*AppMenuWhereInput `json:"hasMenusWith,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                      `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*AppPermissionWhereInput `json:"hasPermissionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppWhereInput) AddPredicates(predicates ...predicate.App) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppWhereInput filter on the AppQuery builder.
func (i *AppWhereInput) Filter(q *AppQuery) (*AppQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppWhereInput is returned in case the AppWhereInput is empty.
var ErrEmptyAppWhereInput = errors.New("ent: empty predicate AppWhereInput")

// P returns a predicate for filtering apps.
// An error is returned if the input is empty or invalid.
func (i *AppWhereInput) P() (predicate.App, error) {
	var predicates []predicate.App
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, app.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.App, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, app.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.App, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, app.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, app.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, app.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, app.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, app.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, app.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, app.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, app.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, app.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, app.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, app.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, app.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, app.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, app.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, app.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, app.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, app.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, app.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, app.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, app.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, app.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, app.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, app.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, app.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, app.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, app.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, app.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, app.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, app.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, app.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, app.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, app.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, app.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, app.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, app.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, app.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, app.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, app.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, app.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, app.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, app.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, app.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, app.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, app.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, app.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, app.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, app.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, app.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, app.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, app.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, app.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, app.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, app.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, app.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, app.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, app.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, app.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, app.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, app.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, app.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, app.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, app.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, app.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, app.KindNotIn(i.KindNotIn...))
	}
	if i.RedirectURI != nil {
		predicates = append(predicates, app.RedirectURIEQ(*i.RedirectURI))
	}
	if i.RedirectURINEQ != nil {
		predicates = append(predicates, app.RedirectURINEQ(*i.RedirectURINEQ))
	}
	if len(i.RedirectURIIn) > 0 {
		predicates = append(predicates, app.RedirectURIIn(i.RedirectURIIn...))
	}
	if len(i.RedirectURINotIn) > 0 {
		predicates = append(predicates, app.RedirectURINotIn(i.RedirectURINotIn...))
	}
	if i.RedirectURIGT != nil {
		predicates = append(predicates, app.RedirectURIGT(*i.RedirectURIGT))
	}
	if i.RedirectURIGTE != nil {
		predicates = append(predicates, app.RedirectURIGTE(*i.RedirectURIGTE))
	}
	if i.RedirectURILT != nil {
		predicates = append(predicates, app.RedirectURILT(*i.RedirectURILT))
	}
	if i.RedirectURILTE != nil {
		predicates = append(predicates, app.RedirectURILTE(*i.RedirectURILTE))
	}
	if i.RedirectURIContains != nil {
		predicates = append(predicates, app.RedirectURIContains(*i.RedirectURIContains))
	}
	if i.RedirectURIHasPrefix != nil {
		predicates = append(predicates, app.RedirectURIHasPrefix(*i.RedirectURIHasPrefix))
	}
	if i.RedirectURIHasSuffix != nil {
		predicates = append(predicates, app.RedirectURIHasSuffix(*i.RedirectURIHasSuffix))
	}
	if i.RedirectURIIsNil {
		predicates = append(predicates, app.RedirectURIIsNil())
	}
	if i.RedirectURINotNil {
		predicates = append(predicates, app.RedirectURINotNil())
	}
	if i.RedirectURIEqualFold != nil {
		predicates = append(predicates, app.RedirectURIEqualFold(*i.RedirectURIEqualFold))
	}
	if i.RedirectURIContainsFold != nil {
		predicates = append(predicates, app.RedirectURIContainsFold(*i.RedirectURIContainsFold))
	}
	if i.AppKey != nil {
		predicates = append(predicates, app.AppKeyEQ(*i.AppKey))
	}
	if i.AppKeyNEQ != nil {
		predicates = append(predicates, app.AppKeyNEQ(*i.AppKeyNEQ))
	}
	if len(i.AppKeyIn) > 0 {
		predicates = append(predicates, app.AppKeyIn(i.AppKeyIn...))
	}
	if len(i.AppKeyNotIn) > 0 {
		predicates = append(predicates, app.AppKeyNotIn(i.AppKeyNotIn...))
	}
	if i.AppKeyGT != nil {
		predicates = append(predicates, app.AppKeyGT(*i.AppKeyGT))
	}
	if i.AppKeyGTE != nil {
		predicates = append(predicates, app.AppKeyGTE(*i.AppKeyGTE))
	}
	if i.AppKeyLT != nil {
		predicates = append(predicates, app.AppKeyLT(*i.AppKeyLT))
	}
	if i.AppKeyLTE != nil {
		predicates = append(predicates, app.AppKeyLTE(*i.AppKeyLTE))
	}
	if i.AppKeyContains != nil {
		predicates = append(predicates, app.AppKeyContains(*i.AppKeyContains))
	}
	if i.AppKeyHasPrefix != nil {
		predicates = append(predicates, app.AppKeyHasPrefix(*i.AppKeyHasPrefix))
	}
	if i.AppKeyHasSuffix != nil {
		predicates = append(predicates, app.AppKeyHasSuffix(*i.AppKeyHasSuffix))
	}
	if i.AppKeyIsNil {
		predicates = append(predicates, app.AppKeyIsNil())
	}
	if i.AppKeyNotNil {
		predicates = append(predicates, app.AppKeyNotNil())
	}
	if i.AppKeyEqualFold != nil {
		predicates = append(predicates, app.AppKeyEqualFold(*i.AppKeyEqualFold))
	}
	if i.AppKeyContainsFold != nil {
		predicates = append(predicates, app.AppKeyContainsFold(*i.AppKeyContainsFold))
	}
	if i.AppSecret != nil {
		predicates = append(predicates, app.AppSecretEQ(*i.AppSecret))
	}
	if i.AppSecretNEQ != nil {
		predicates = append(predicates, app.AppSecretNEQ(*i.AppSecretNEQ))
	}
	if len(i.AppSecretIn) > 0 {
		predicates = append(predicates, app.AppSecretIn(i.AppSecretIn...))
	}
	if len(i.AppSecretNotIn) > 0 {
		predicates = append(predicates, app.AppSecretNotIn(i.AppSecretNotIn...))
	}
	if i.AppSecretGT != nil {
		predicates = append(predicates, app.AppSecretGT(*i.AppSecretGT))
	}
	if i.AppSecretGTE != nil {
		predicates = append(predicates, app.AppSecretGTE(*i.AppSecretGTE))
	}
	if i.AppSecretLT != nil {
		predicates = append(predicates, app.AppSecretLT(*i.AppSecretLT))
	}
	if i.AppSecretLTE != nil {
		predicates = append(predicates, app.AppSecretLTE(*i.AppSecretLTE))
	}
	if i.AppSecretContains != nil {
		predicates = append(predicates, app.AppSecretContains(*i.AppSecretContains))
	}
	if i.AppSecretHasPrefix != nil {
		predicates = append(predicates, app.AppSecretHasPrefix(*i.AppSecretHasPrefix))
	}
	if i.AppSecretHasSuffix != nil {
		predicates = append(predicates, app.AppSecretHasSuffix(*i.AppSecretHasSuffix))
	}
	if i.AppSecretIsNil {
		predicates = append(predicates, app.AppSecretIsNil())
	}
	if i.AppSecretNotNil {
		predicates = append(predicates, app.AppSecretNotNil())
	}
	if i.AppSecretEqualFold != nil {
		predicates = append(predicates, app.AppSecretEqualFold(*i.AppSecretEqualFold))
	}
	if i.AppSecretContainsFold != nil {
		predicates = append(predicates, app.AppSecretContainsFold(*i.AppSecretContainsFold))
	}
	if i.Scopes != nil {
		predicates = append(predicates, app.ScopesEQ(*i.Scopes))
	}
	if i.ScopesNEQ != nil {
		predicates = append(predicates, app.ScopesNEQ(*i.ScopesNEQ))
	}
	if len(i.ScopesIn) > 0 {
		predicates = append(predicates, app.ScopesIn(i.ScopesIn...))
	}
	if len(i.ScopesNotIn) > 0 {
		predicates = append(predicates, app.ScopesNotIn(i.ScopesNotIn...))
	}
	if i.ScopesGT != nil {
		predicates = append(predicates, app.ScopesGT(*i.ScopesGT))
	}
	if i.ScopesGTE != nil {
		predicates = append(predicates, app.ScopesGTE(*i.ScopesGTE))
	}
	if i.ScopesLT != nil {
		predicates = append(predicates, app.ScopesLT(*i.ScopesLT))
	}
	if i.ScopesLTE != nil {
		predicates = append(predicates, app.ScopesLTE(*i.ScopesLTE))
	}
	if i.ScopesContains != nil {
		predicates = append(predicates, app.ScopesContains(*i.ScopesContains))
	}
	if i.ScopesHasPrefix != nil {
		predicates = append(predicates, app.ScopesHasPrefix(*i.ScopesHasPrefix))
	}
	if i.ScopesHasSuffix != nil {
		predicates = append(predicates, app.ScopesHasSuffix(*i.ScopesHasSuffix))
	}
	if i.ScopesIsNil {
		predicates = append(predicates, app.ScopesIsNil())
	}
	if i.ScopesNotNil {
		predicates = append(predicates, app.ScopesNotNil())
	}
	if i.ScopesEqualFold != nil {
		predicates = append(predicates, app.ScopesEqualFold(*i.ScopesEqualFold))
	}
	if i.ScopesContainsFold != nil {
		predicates = append(predicates, app.ScopesContainsFold(*i.ScopesContainsFold))
	}
	if i.TokenValidity != nil {
		predicates = append(predicates, app.TokenValidityEQ(*i.TokenValidity))
	}
	if i.TokenValidityNEQ != nil {
		predicates = append(predicates, app.TokenValidityNEQ(*i.TokenValidityNEQ))
	}
	if len(i.TokenValidityIn) > 0 {
		predicates = append(predicates, app.TokenValidityIn(i.TokenValidityIn...))
	}
	if len(i.TokenValidityNotIn) > 0 {
		predicates = append(predicates, app.TokenValidityNotIn(i.TokenValidityNotIn...))
	}
	if i.TokenValidityGT != nil {
		predicates = append(predicates, app.TokenValidityGT(*i.TokenValidityGT))
	}
	if i.TokenValidityGTE != nil {
		predicates = append(predicates, app.TokenValidityGTE(*i.TokenValidityGTE))
	}
	if i.TokenValidityLT != nil {
		predicates = append(predicates, app.TokenValidityLT(*i.TokenValidityLT))
	}
	if i.TokenValidityLTE != nil {
		predicates = append(predicates, app.TokenValidityLTE(*i.TokenValidityLTE))
	}
	if i.TokenValidityIsNil {
		predicates = append(predicates, app.TokenValidityIsNil())
	}
	if i.TokenValidityNotNil {
		predicates = append(predicates, app.TokenValidityNotNil())
	}
	if i.RefreshTokenValidity != nil {
		predicates = append(predicates, app.RefreshTokenValidityEQ(*i.RefreshTokenValidity))
	}
	if i.RefreshTokenValidityNEQ != nil {
		predicates = append(predicates, app.RefreshTokenValidityNEQ(*i.RefreshTokenValidityNEQ))
	}
	if len(i.RefreshTokenValidityIn) > 0 {
		predicates = append(predicates, app.RefreshTokenValidityIn(i.RefreshTokenValidityIn...))
	}
	if len(i.RefreshTokenValidityNotIn) > 0 {
		predicates = append(predicates, app.RefreshTokenValidityNotIn(i.RefreshTokenValidityNotIn...))
	}
	if i.RefreshTokenValidityGT != nil {
		predicates = append(predicates, app.RefreshTokenValidityGT(*i.RefreshTokenValidityGT))
	}
	if i.RefreshTokenValidityGTE != nil {
		predicates = append(predicates, app.RefreshTokenValidityGTE(*i.RefreshTokenValidityGTE))
	}
	if i.RefreshTokenValidityLT != nil {
		predicates = append(predicates, app.RefreshTokenValidityLT(*i.RefreshTokenValidityLT))
	}
	if i.RefreshTokenValidityLTE != nil {
		predicates = append(predicates, app.RefreshTokenValidityLTE(*i.RefreshTokenValidityLTE))
	}
	if i.RefreshTokenValidityIsNil {
		predicates = append(predicates, app.RefreshTokenValidityIsNil())
	}
	if i.RefreshTokenValidityNotNil {
		predicates = append(predicates, app.RefreshTokenValidityNotNil())
	}
	if i.Logo != nil {
		predicates = append(predicates, app.LogoEQ(*i.Logo))
	}
	if i.LogoNEQ != nil {
		predicates = append(predicates, app.LogoNEQ(*i.LogoNEQ))
	}
	if len(i.LogoIn) > 0 {
		predicates = append(predicates, app.LogoIn(i.LogoIn...))
	}
	if len(i.LogoNotIn) > 0 {
		predicates = append(predicates, app.LogoNotIn(i.LogoNotIn...))
	}
	if i.LogoGT != nil {
		predicates = append(predicates, app.LogoGT(*i.LogoGT))
	}
	if i.LogoGTE != nil {
		predicates = append(predicates, app.LogoGTE(*i.LogoGTE))
	}
	if i.LogoLT != nil {
		predicates = append(predicates, app.LogoLT(*i.LogoLT))
	}
	if i.LogoLTE != nil {
		predicates = append(predicates, app.LogoLTE(*i.LogoLTE))
	}
	if i.LogoContains != nil {
		predicates = append(predicates, app.LogoContains(*i.LogoContains))
	}
	if i.LogoHasPrefix != nil {
		predicates = append(predicates, app.LogoHasPrefix(*i.LogoHasPrefix))
	}
	if i.LogoHasSuffix != nil {
		predicates = append(predicates, app.LogoHasSuffix(*i.LogoHasSuffix))
	}
	if i.LogoIsNil {
		predicates = append(predicates, app.LogoIsNil())
	}
	if i.LogoNotNil {
		predicates = append(predicates, app.LogoNotNil())
	}
	if i.LogoEqualFold != nil {
		predicates = append(predicates, app.LogoEqualFold(*i.LogoEqualFold))
	}
	if i.LogoContainsFold != nil {
		predicates = append(predicates, app.LogoContainsFold(*i.LogoContainsFold))
	}
	if i.Comments != nil {
		predicates = append(predicates, app.CommentsEQ(*i.Comments))
	}
	if i.CommentsNEQ != nil {
		predicates = append(predicates, app.CommentsNEQ(*i.CommentsNEQ))
	}
	if len(i.CommentsIn) > 0 {
		predicates = append(predicates, app.CommentsIn(i.CommentsIn...))
	}
	if len(i.CommentsNotIn) > 0 {
		predicates = append(predicates, app.CommentsNotIn(i.CommentsNotIn...))
	}
	if i.CommentsGT != nil {
		predicates = append(predicates, app.CommentsGT(*i.CommentsGT))
	}
	if i.CommentsGTE != nil {
		predicates = append(predicates, app.CommentsGTE(*i.CommentsGTE))
	}
	if i.CommentsLT != nil {
		predicates = append(predicates, app.CommentsLT(*i.CommentsLT))
	}
	if i.CommentsLTE != nil {
		predicates = append(predicates, app.CommentsLTE(*i.CommentsLTE))
	}
	if i.CommentsContains != nil {
		predicates = append(predicates, app.CommentsContains(*i.CommentsContains))
	}
	if i.CommentsHasPrefix != nil {
		predicates = append(predicates, app.CommentsHasPrefix(*i.CommentsHasPrefix))
	}
	if i.CommentsHasSuffix != nil {
		predicates = append(predicates, app.CommentsHasSuffix(*i.CommentsHasSuffix))
	}
	if i.CommentsIsNil {
		predicates = append(predicates, app.CommentsIsNil())
	}
	if i.CommentsNotNil {
		predicates = append(predicates, app.CommentsNotNil())
	}
	if i.CommentsEqualFold != nil {
		predicates = append(predicates, app.CommentsEqualFold(*i.CommentsEqualFold))
	}
	if i.CommentsContainsFold != nil {
		predicates = append(predicates, app.CommentsContainsFold(*i.CommentsContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, app.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, app.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, app.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, app.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, app.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, app.StatusNotNil())
	}

	if i.HasMenus != nil {
		p := app.HasMenus()
		if !*i.HasMenus {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMenusWith) > 0 {
		with := make([]predicate.AppMenu, 0, len(i.HasMenusWith))
		for _, w := range i.HasMenusWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMenusWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasMenusWith(with...))
	}
	if i.HasPermissions != nil {
		p := app.HasPermissions()
		if !*i.HasPermissions {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.AppPermission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasPermissionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppWhereInput
	case 1:
		return predicates[0], nil
	default:
		return app.And(predicates...), nil
	}
}

// AppMenuWhereInput represents a where input for filtering AppMenu queries.
type AppMenuWhereInput struct {
	Predicates []predicate.AppMenu  `json:"-"`
	Not        *AppMenuWhereInput   `json:"not,omitempty"`
	Or         []*AppMenuWhereInput `json:"or,omitempty"`
	And        []*AppMenuWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`

	// "parent_id" field predicates.
	ParentID      *int  `json:"parentID,omitempty"`
	ParentIDNEQ   *int  `json:"parentIDNEQ,omitempty"`
	ParentIDIn    []int `json:"parentIDIn,omitempty"`
	ParentIDNotIn []int `json:"parentIDNotIn,omitempty"`
	ParentIDGT    *int  `json:"parentIDGT,omitempty"`
	ParentIDGTE   *int  `json:"parentIDGTE,omitempty"`
	ParentIDLT    *int  `json:"parentIDLT,omitempty"`
	ParentIDLTE   *int  `json:"parentIDLTE,omitempty"`

	// "kind" field predicates.
	Kind      *appmenu.Kind  `json:"kind,omitempty"`
	KindNEQ   *appmenu.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []appmenu.Kind `json:"kindIn,omitempty"`
	KindNotIn []appmenu.Kind `json:"kindNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "permission_id" field predicates.
	PermissionID       *int  `json:"permissionID,omitempty"`
	PermissionIDNEQ    *int  `json:"permissionIDNEQ,omitempty"`
	PermissionIDIn     []int `json:"permissionIDIn,omitempty"`
	PermissionIDNotIn  []int `json:"permissionIDNotIn,omitempty"`
	PermissionIDIsNil  bool  `json:"permissionIDIsNil,omitempty"`
	PermissionIDNotNil bool  `json:"permissionIDNotNil,omitempty"`

	// "app" edge predicates.
	HasApp     *bool            `json:"hasApp,omitempty"`
	HasAppWith []*AppWhereInput `json:"hasAppWith,omitempty"`

	// "permission" edge predicates.
	HasPermission     *bool                      `json:"hasPermission,omitempty"`
	HasPermissionWith []*AppPermissionWhereInput `json:"hasPermissionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppMenuWhereInput) AddPredicates(predicates ...predicate.AppMenu) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppMenuWhereInput filter on the AppMenuQuery builder.
func (i *AppMenuWhereInput) Filter(q *AppMenuQuery) (*AppMenuQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppMenuWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppMenuWhereInput is returned in case the AppMenuWhereInput is empty.
var ErrEmptyAppMenuWhereInput = errors.New("ent: empty predicate AppMenuWhereInput")

// P returns a predicate for filtering appmenus.
// An error is returned if the input is empty or invalid.
func (i *AppMenuWhereInput) P() (predicate.AppMenu, error) {
	var predicates []predicate.AppMenu
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, appmenu.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AppMenu, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, appmenu.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AppMenu, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, appmenu.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, appmenu.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, appmenu.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, appmenu.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, appmenu.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, appmenu.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, appmenu.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, appmenu.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, appmenu.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, appmenu.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, appmenu.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, appmenu.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, appmenu.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, appmenu.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, appmenu.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, appmenu.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, appmenu.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, appmenu.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, appmenu.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, appmenu.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, appmenu.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, appmenu.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, appmenu.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, appmenu.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, appmenu.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, appmenu.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, appmenu.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, appmenu.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, appmenu.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, appmenu.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, appmenu.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, appmenu.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, appmenu.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, appmenu.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, appmenu.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, appmenu.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, appmenu.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, appmenu.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, appmenu.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, appmenu.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, appmenu.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, appmenu.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, appmenu.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, appmenu.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, appmenu.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.ParentID != nil {
		predicates = append(predicates, appmenu.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, appmenu.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, appmenu.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, appmenu.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, appmenu.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, appmenu.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, appmenu.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, appmenu.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.Kind != nil {
		predicates = append(predicates, appmenu.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, appmenu.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, appmenu.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, appmenu.KindNotIn(i.KindNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, appmenu.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, appmenu.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, appmenu.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, appmenu.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, appmenu.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, appmenu.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, appmenu.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, appmenu.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, appmenu.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, appmenu.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, appmenu.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, appmenu.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, appmenu.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, appmenu.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, appmenu.NameContainsFold(*i.NameContainsFold))
	}
	if i.PermissionID != nil {
		predicates = append(predicates, appmenu.PermissionIDEQ(*i.PermissionID))
	}
	if i.PermissionIDNEQ != nil {
		predicates = append(predicates, appmenu.PermissionIDNEQ(*i.PermissionIDNEQ))
	}
	if len(i.PermissionIDIn) > 0 {
		predicates = append(predicates, appmenu.PermissionIDIn(i.PermissionIDIn...))
	}
	if len(i.PermissionIDNotIn) > 0 {
		predicates = append(predicates, appmenu.PermissionIDNotIn(i.PermissionIDNotIn...))
	}
	if i.PermissionIDIsNil {
		predicates = append(predicates, appmenu.PermissionIDIsNil())
	}
	if i.PermissionIDNotNil {
		predicates = append(predicates, appmenu.PermissionIDNotNil())
	}

	if i.HasApp != nil {
		p := appmenu.HasApp()
		if !*i.HasApp {
			p = appmenu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppWith))
		for _, w := range i.HasAppWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appmenu.HasAppWith(with...))
	}
	if i.HasPermission != nil {
		p := appmenu.HasPermission()
		if !*i.HasPermission {
			p = appmenu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionWith) > 0 {
		with := make([]predicate.AppPermission, 0, len(i.HasPermissionWith))
		for _, w := range i.HasPermissionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appmenu.HasPermissionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppMenuWhereInput
	case 1:
		return predicates[0], nil
	default:
		return appmenu.And(predicates...), nil
	}
}

// AppPermissionWhereInput represents a where input for filtering AppPermission queries.
type AppPermissionWhereInput struct {
	Predicates []predicate.AppPermission  `json:"-"`
	Not        *AppPermissionWhereInput   `json:"not,omitempty"`
	Or         []*AppPermissionWhereInput `json:"or,omitempty"`
	And        []*AppPermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "app" edge predicates.
	HasApp     *bool            `json:"hasApp,omitempty"`
	HasAppWith []*AppWhereInput `json:"hasAppWith,omitempty"`

	// "menus" edge predicates.
	HasMenus     *bool                `json:"hasMenus,omitempty"`
	HasMenusWith []*AppMenuWhereInput `json:"hasMenusWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppPermissionWhereInput) AddPredicates(predicates ...predicate.AppPermission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppPermissionWhereInput filter on the AppPermissionQuery builder.
func (i *AppPermissionWhereInput) Filter(q *AppPermissionQuery) (*AppPermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppPermissionWhereInput is returned in case the AppPermissionWhereInput is empty.
var ErrEmptyAppPermissionWhereInput = errors.New("ent: empty predicate AppPermissionWhereInput")

// P returns a predicate for filtering apppermissions.
// An error is returned if the input is empty or invalid.
func (i *AppPermissionWhereInput) P() (predicate.AppPermission, error) {
	var predicates []predicate.AppPermission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apppermission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AppPermission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apppermission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AppPermission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apppermission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apppermission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apppermission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apppermission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apppermission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apppermission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apppermission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apppermission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apppermission.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, apppermission.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, apppermission.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, apppermission.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, apppermission.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, apppermission.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, apppermission.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, apppermission.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, apppermission.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apppermission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apppermission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apppermission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apppermission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apppermission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apppermission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apppermission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apppermission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, apppermission.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, apppermission.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, apppermission.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, apppermission.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, apppermission.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, apppermission.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, apppermission.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, apppermission.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, apppermission.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, apppermission.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, apppermission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, apppermission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, apppermission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, apppermission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, apppermission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, apppermission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, apppermission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, apppermission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, apppermission.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, apppermission.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, apppermission.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, apppermission.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, apppermission.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, apppermission.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, apppermission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apppermission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apppermission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apppermission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apppermission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apppermission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apppermission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apppermission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apppermission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apppermission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apppermission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, apppermission.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, apppermission.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apppermission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apppermission.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasApp != nil {
		p := apppermission.HasApp()
		if !*i.HasApp {
			p = apppermission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppWith))
		for _, w := range i.HasAppWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apppermission.HasAppWith(with...))
	}
	if i.HasMenus != nil {
		p := apppermission.HasMenus()
		if !*i.HasMenus {
			p = apppermission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMenusWith) > 0 {
		with := make([]predicate.AppMenu, 0, len(i.HasMenusWith))
		for _, w := range i.HasMenusWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMenusWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apppermission.HasMenusWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apppermission.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Predicates []predicate.Organization  `json:"-"`
	Not        *OrganizationWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationWhereInput `json:"or,omitempty"`
	And        []*OrganizationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "owner_id" field predicates.
	OwnerID       *int  `json:"ownerID,omitempty"`
	OwnerIDNEQ    *int  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn     []int `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn  []int `json:"ownerIDNotIn,omitempty"`
	OwnerIDIsNil  bool  `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil bool  `json:"ownerIDNotNil,omitempty"`

	// "parent_id" field predicates.
	ParentID      *int  `json:"parentID,omitempty"`
	ParentIDNEQ   *int  `json:"parentIDNEQ,omitempty"`
	ParentIDIn    []int `json:"parentIDIn,omitempty"`
	ParentIDNotIn []int `json:"parentIDNotIn,omitempty"`

	// "domain" field predicates.
	Domain             *string  `json:"domain,omitempty"`
	DomainNEQ          *string  `json:"domainNEQ,omitempty"`
	DomainIn           []string `json:"domainIn,omitempty"`
	DomainNotIn        []string `json:"domainNotIn,omitempty"`
	DomainGT           *string  `json:"domainGT,omitempty"`
	DomainGTE          *string  `json:"domainGTE,omitempty"`
	DomainLT           *string  `json:"domainLT,omitempty"`
	DomainLTE          *string  `json:"domainLTE,omitempty"`
	DomainContains     *string  `json:"domainContains,omitempty"`
	DomainHasPrefix    *string  `json:"domainHasPrefix,omitempty"`
	DomainHasSuffix    *string  `json:"domainHasSuffix,omitempty"`
	DomainIsNil        bool     `json:"domainIsNil,omitempty"`
	DomainNotNil       bool     `json:"domainNotNil,omitempty"`
	DomainEqualFold    *string  `json:"domainEqualFold,omitempty"`
	DomainContainsFold *string  `json:"domainContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeIsNil        bool     `json:"codeIsNil,omitempty"`
	CodeNotNil       bool     `json:"codeNotNil,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *organization.Status  `json:"status,omitempty"`
	StatusNEQ    *organization.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []organization.Status `json:"statusIn,omitempty"`
	StatusNotIn  []organization.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil bool                  `json:"statusNotNil,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathIsNil        bool     `json:"pathIsNil,omitempty"`
	PathNotNil       bool     `json:"pathNotNil,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "country_code" field predicates.
	CountryCode             *string  `json:"countryCode,omitempty"`
	CountryCodeNEQ          *string  `json:"countryCodeNEQ,omitempty"`
	CountryCodeIn           []string `json:"countryCodeIn,omitempty"`
	CountryCodeNotIn        []string `json:"countryCodeNotIn,omitempty"`
	CountryCodeGT           *string  `json:"countryCodeGT,omitempty"`
	CountryCodeGTE          *string  `json:"countryCodeGTE,omitempty"`
	CountryCodeLT           *string  `json:"countryCodeLT,omitempty"`
	CountryCodeLTE          *string  `json:"countryCodeLTE,omitempty"`
	CountryCodeContains     *string  `json:"countryCodeContains,omitempty"`
	CountryCodeHasPrefix    *string  `json:"countryCodeHasPrefix,omitempty"`
	CountryCodeHasSuffix    *string  `json:"countryCodeHasSuffix,omitempty"`
	CountryCodeIsNil        bool     `json:"countryCodeIsNil,omitempty"`
	CountryCodeNotNil       bool     `json:"countryCodeNotNil,omitempty"`
	CountryCodeEqualFold    *string  `json:"countryCodeEqualFold,omitempty"`
	CountryCodeContainsFold *string  `json:"countryCodeContainsFold,omitempty"`

	// "timezone" field predicates.
	Timezone             *string  `json:"timezone,omitempty"`
	TimezoneNEQ          *string  `json:"timezoneNEQ,omitempty"`
	TimezoneIn           []string `json:"timezoneIn,omitempty"`
	TimezoneNotIn        []string `json:"timezoneNotIn,omitempty"`
	TimezoneGT           *string  `json:"timezoneGT,omitempty"`
	TimezoneGTE          *string  `json:"timezoneGTE,omitempty"`
	TimezoneLT           *string  `json:"timezoneLT,omitempty"`
	TimezoneLTE          *string  `json:"timezoneLTE,omitempty"`
	TimezoneContains     *string  `json:"timezoneContains,omitempty"`
	TimezoneHasPrefix    *string  `json:"timezoneHasPrefix,omitempty"`
	TimezoneHasSuffix    *string  `json:"timezoneHasSuffix,omitempty"`
	TimezoneIsNil        bool     `json:"timezoneIsNil,omitempty"`
	TimezoneNotNil       bool     `json:"timezoneNotNil,omitempty"`
	TimezoneEqualFold    *string  `json:"timezoneEqualFold,omitempty"`
	TimezoneContainsFold *string  `json:"timezoneContainsFold,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationWhereInput) AddPredicates(predicates ...predicate.Organization) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationWhereInput is returned in case the OrganizationWhereInput is empty.
var ErrEmptyOrganizationWhereInput = errors.New("ent: empty predicate OrganizationWhereInput")

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organization.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organization.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organization.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organization.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organization.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organization.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organization.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organization.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organization.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organization.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organization.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organization.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organization.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organization.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organization.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organization.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organization.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organization.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organization.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organization.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organization.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organization.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organization.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organization.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organization.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organization.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organization.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organization.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organization.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organization.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organization.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organization.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, organization.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, organization.UpdatedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, organization.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, organization.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, organization.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, organization.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, organization.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, organization.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, organization.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, organization.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, organization.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, organization.DeletedAtNotNil())
	}
	if i.OwnerID != nil {
		predicates = append(predicates, organization.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, organization.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, organization.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, organization.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, organization.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, organization.OwnerIDNotNil())
	}
	if i.ParentID != nil {
		predicates = append(predicates, organization.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, organization.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, organization.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, organization.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.Domain != nil {
		predicates = append(predicates, organization.DomainEQ(*i.Domain))
	}
	if i.DomainNEQ != nil {
		predicates = append(predicates, organization.DomainNEQ(*i.DomainNEQ))
	}
	if len(i.DomainIn) > 0 {
		predicates = append(predicates, organization.DomainIn(i.DomainIn...))
	}
	if len(i.DomainNotIn) > 0 {
		predicates = append(predicates, organization.DomainNotIn(i.DomainNotIn...))
	}
	if i.DomainGT != nil {
		predicates = append(predicates, organization.DomainGT(*i.DomainGT))
	}
	if i.DomainGTE != nil {
		predicates = append(predicates, organization.DomainGTE(*i.DomainGTE))
	}
	if i.DomainLT != nil {
		predicates = append(predicates, organization.DomainLT(*i.DomainLT))
	}
	if i.DomainLTE != nil {
		predicates = append(predicates, organization.DomainLTE(*i.DomainLTE))
	}
	if i.DomainContains != nil {
		predicates = append(predicates, organization.DomainContains(*i.DomainContains))
	}
	if i.DomainHasPrefix != nil {
		predicates = append(predicates, organization.DomainHasPrefix(*i.DomainHasPrefix))
	}
	if i.DomainHasSuffix != nil {
		predicates = append(predicates, organization.DomainHasSuffix(*i.DomainHasSuffix))
	}
	if i.DomainIsNil {
		predicates = append(predicates, organization.DomainIsNil())
	}
	if i.DomainNotNil {
		predicates = append(predicates, organization.DomainNotNil())
	}
	if i.DomainEqualFold != nil {
		predicates = append(predicates, organization.DomainEqualFold(*i.DomainEqualFold))
	}
	if i.DomainContainsFold != nil {
		predicates = append(predicates, organization.DomainContainsFold(*i.DomainContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, organization.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, organization.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, organization.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, organization.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, organization.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, organization.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, organization.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, organization.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, organization.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, organization.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, organization.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeIsNil {
		predicates = append(predicates, organization.CodeIsNil())
	}
	if i.CodeNotNil {
		predicates = append(predicates, organization.CodeNotNil())
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, organization.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, organization.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, organization.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, organization.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, organization.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, organization.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, organization.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, organization.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, organization.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, organization.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, organization.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, organization.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, organization.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, organization.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, organization.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, organization.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, organization.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, organization.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, organization.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, organization.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, organization.StatusNotNil())
	}
	if i.Path != nil {
		predicates = append(predicates, organization.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, organization.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, organization.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, organization.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, organization.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, organization.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, organization.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, organization.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, organization.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, organization.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, organization.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathIsNil {
		predicates = append(predicates, organization.PathIsNil())
	}
	if i.PathNotNil {
		predicates = append(predicates, organization.PathNotNil())
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, organization.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, organization.PathContainsFold(*i.PathContainsFold))
	}
	if i.CountryCode != nil {
		predicates = append(predicates, organization.CountryCodeEQ(*i.CountryCode))
	}
	if i.CountryCodeNEQ != nil {
		predicates = append(predicates, organization.CountryCodeNEQ(*i.CountryCodeNEQ))
	}
	if len(i.CountryCodeIn) > 0 {
		predicates = append(predicates, organization.CountryCodeIn(i.CountryCodeIn...))
	}
	if len(i.CountryCodeNotIn) > 0 {
		predicates = append(predicates, organization.CountryCodeNotIn(i.CountryCodeNotIn...))
	}
	if i.CountryCodeGT != nil {
		predicates = append(predicates, organization.CountryCodeGT(*i.CountryCodeGT))
	}
	if i.CountryCodeGTE != nil {
		predicates = append(predicates, organization.CountryCodeGTE(*i.CountryCodeGTE))
	}
	if i.CountryCodeLT != nil {
		predicates = append(predicates, organization.CountryCodeLT(*i.CountryCodeLT))
	}
	if i.CountryCodeLTE != nil {
		predicates = append(predicates, organization.CountryCodeLTE(*i.CountryCodeLTE))
	}
	if i.CountryCodeContains != nil {
		predicates = append(predicates, organization.CountryCodeContains(*i.CountryCodeContains))
	}
	if i.CountryCodeHasPrefix != nil {
		predicates = append(predicates, organization.CountryCodeHasPrefix(*i.CountryCodeHasPrefix))
	}
	if i.CountryCodeHasSuffix != nil {
		predicates = append(predicates, organization.CountryCodeHasSuffix(*i.CountryCodeHasSuffix))
	}
	if i.CountryCodeIsNil {
		predicates = append(predicates, organization.CountryCodeIsNil())
	}
	if i.CountryCodeNotNil {
		predicates = append(predicates, organization.CountryCodeNotNil())
	}
	if i.CountryCodeEqualFold != nil {
		predicates = append(predicates, organization.CountryCodeEqualFold(*i.CountryCodeEqualFold))
	}
	if i.CountryCodeContainsFold != nil {
		predicates = append(predicates, organization.CountryCodeContainsFold(*i.CountryCodeContainsFold))
	}
	if i.Timezone != nil {
		predicates = append(predicates, organization.TimezoneEQ(*i.Timezone))
	}
	if i.TimezoneNEQ != nil {
		predicates = append(predicates, organization.TimezoneNEQ(*i.TimezoneNEQ))
	}
	if len(i.TimezoneIn) > 0 {
		predicates = append(predicates, organization.TimezoneIn(i.TimezoneIn...))
	}
	if len(i.TimezoneNotIn) > 0 {
		predicates = append(predicates, organization.TimezoneNotIn(i.TimezoneNotIn...))
	}
	if i.TimezoneGT != nil {
		predicates = append(predicates, organization.TimezoneGT(*i.TimezoneGT))
	}
	if i.TimezoneGTE != nil {
		predicates = append(predicates, organization.TimezoneGTE(*i.TimezoneGTE))
	}
	if i.TimezoneLT != nil {
		predicates = append(predicates, organization.TimezoneLT(*i.TimezoneLT))
	}
	if i.TimezoneLTE != nil {
		predicates = append(predicates, organization.TimezoneLTE(*i.TimezoneLTE))
	}
	if i.TimezoneContains != nil {
		predicates = append(predicates, organization.TimezoneContains(*i.TimezoneContains))
	}
	if i.TimezoneHasPrefix != nil {
		predicates = append(predicates, organization.TimezoneHasPrefix(*i.TimezoneHasPrefix))
	}
	if i.TimezoneHasSuffix != nil {
		predicates = append(predicates, organization.TimezoneHasSuffix(*i.TimezoneHasSuffix))
	}
	if i.TimezoneIsNil {
		predicates = append(predicates, organization.TimezoneIsNil())
	}
	if i.TimezoneNotNil {
		predicates = append(predicates, organization.TimezoneNotNil())
	}
	if i.TimezoneEqualFold != nil {
		predicates = append(predicates, organization.TimezoneEqualFold(*i.TimezoneEqualFold))
	}
	if i.TimezoneContainsFold != nil {
		predicates = append(predicates, organization.TimezoneContainsFold(*i.TimezoneContainsFold))
	}

	if i.HasParent != nil {
		p := organization.HasParent()
		if !*i.HasParent {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := organization.HasChildren()
		if !*i.HasChildren {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasChildrenWith(with...))
	}
	if i.HasOwner != nil {
		p := organization.HasOwner()
		if !*i.HasOwner {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// OrganizationUserWhereInput represents a where input for filtering OrganizationUser queries.
type OrganizationUserWhereInput struct {
	Predicates []predicate.OrganizationUser  `json:"-"`
	Not        *OrganizationUserWhereInput   `json:"not,omitempty"`
	Or         []*OrganizationUserWhereInput `json:"or,omitempty"`
	And        []*OrganizationUserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "org_id" field predicates.
	OrgID      *int  `json:"orgID,omitempty"`
	OrgIDNEQ   *int  `json:"orgIDNEQ,omitempty"`
	OrgIDIn    []int `json:"orgIDIn,omitempty"`
	OrgIDNotIn []int `json:"orgIDNotIn,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrganizationUserWhereInput) AddPredicates(predicates ...predicate.OrganizationUser) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrganizationUserWhereInput filter on the OrganizationUserQuery builder.
func (i *OrganizationUserWhereInput) Filter(q *OrganizationUserQuery) (*OrganizationUserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrganizationUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrganizationUserWhereInput is returned in case the OrganizationUserWhereInput is empty.
var ErrEmptyOrganizationUserWhereInput = errors.New("ent: empty predicate OrganizationUserWhereInput")

// P returns a predicate for filtering organizationusers.
// An error is returned if the input is empty or invalid.
func (i *OrganizationUserWhereInput) P() (predicate.OrganizationUser, error) {
	var predicates []predicate.OrganizationUser
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, organizationuser.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrganizationUser, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, organizationuser.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrganizationUser, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, organizationuser.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, organizationuser.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organizationuser.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organizationuser.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organizationuser.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organizationuser.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organizationuser.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organizationuser.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organizationuser.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, organizationuser.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, organizationuser.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, organizationuser.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, organizationuser.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, organizationuser.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, organizationuser.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, organizationuser.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, organizationuser.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, organizationuser.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, organizationuser.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, organizationuser.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, organizationuser.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, organizationuser.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, organizationuser.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, organizationuser.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, organizationuser.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, organizationuser.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, organizationuser.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, organizationuser.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, organizationuser.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, organizationuser.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, organizationuser.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, organizationuser.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, organizationuser.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, organizationuser.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, organizationuser.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, organizationuser.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, organizationuser.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, organizationuser.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, organizationuser.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, organizationuser.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, organizationuser.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, organizationuser.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, organizationuser.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, organizationuser.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, organizationuser.UpdatedAtNotNil())
	}
	if i.OrgID != nil {
		predicates = append(predicates, organizationuser.OrgIDEQ(*i.OrgID))
	}
	if i.OrgIDNEQ != nil {
		predicates = append(predicates, organizationuser.OrgIDNEQ(*i.OrgIDNEQ))
	}
	if len(i.OrgIDIn) > 0 {
		predicates = append(predicates, organizationuser.OrgIDIn(i.OrgIDIn...))
	}
	if len(i.OrgIDNotIn) > 0 {
		predicates = append(predicates, organizationuser.OrgIDNotIn(i.OrgIDNotIn...))
	}
	if i.UserID != nil {
		predicates = append(predicates, organizationuser.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, organizationuser.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, organizationuser.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, organizationuser.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, organizationuser.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, organizationuser.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, organizationuser.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, organizationuser.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, organizationuser.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, organizationuser.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, organizationuser.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, organizationuser.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, organizationuser.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, organizationuser.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, organizationuser.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, organizationuser.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, organizationuser.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrganizationUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return organizationuser.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "principal_name" field predicates.
	PrincipalName             *string  `json:"principalName,omitempty"`
	PrincipalNameNEQ          *string  `json:"principalNameNEQ,omitempty"`
	PrincipalNameIn           []string `json:"principalNameIn,omitempty"`
	PrincipalNameNotIn        []string `json:"principalNameNotIn,omitempty"`
	PrincipalNameGT           *string  `json:"principalNameGT,omitempty"`
	PrincipalNameGTE          *string  `json:"principalNameGTE,omitempty"`
	PrincipalNameLT           *string  `json:"principalNameLT,omitempty"`
	PrincipalNameLTE          *string  `json:"principalNameLTE,omitempty"`
	PrincipalNameContains     *string  `json:"principalNameContains,omitempty"`
	PrincipalNameHasPrefix    *string  `json:"principalNameHasPrefix,omitempty"`
	PrincipalNameHasSuffix    *string  `json:"principalNameHasSuffix,omitempty"`
	PrincipalNameEqualFold    *string  `json:"principalNameEqualFold,omitempty"`
	PrincipalNameContainsFold *string  `json:"principalNameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "creation_type" field predicates.
	CreationType      *user.CreationType  `json:"creationType,omitempty"`
	CreationTypeNEQ   *user.CreationType  `json:"creationTypeNEQ,omitempty"`
	CreationTypeIn    []user.CreationType `json:"creationTypeIn,omitempty"`
	CreationTypeNotIn []user.CreationType `json:"creationTypeNotIn,omitempty"`

	// "register_ip" field predicates.
	RegisterIP             *string  `json:"registerIP,omitempty"`
	RegisterIPNEQ          *string  `json:"registerIPNEQ,omitempty"`
	RegisterIPIn           []string `json:"registerIPIn,omitempty"`
	RegisterIPNotIn        []string `json:"registerIPNotIn,omitempty"`
	RegisterIPGT           *string  `json:"registerIPGT,omitempty"`
	RegisterIPGTE          *string  `json:"registerIPGTE,omitempty"`
	RegisterIPLT           *string  `json:"registerIPLT,omitempty"`
	RegisterIPLTE          *string  `json:"registerIPLTE,omitempty"`
	RegisterIPContains     *string  `json:"registerIPContains,omitempty"`
	RegisterIPHasPrefix    *string  `json:"registerIPHasPrefix,omitempty"`
	RegisterIPHasSuffix    *string  `json:"registerIPHasSuffix,omitempty"`
	RegisterIPEqualFold    *string  `json:"registerIPEqualFold,omitempty"`
	RegisterIPContainsFold *string  `json:"registerIPContainsFold,omitempty"`

	// "status" field predicates.
	Status       *user.Status  `json:"status,omitempty"`
	StatusNEQ    *user.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []user.Status `json:"statusIn,omitempty"`
	StatusNotIn  []user.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool          `json:"statusIsNil,omitempty"`
	StatusNotNil bool          `json:"statusNotNil,omitempty"`

	// "identities" edge predicates.
	HasIdentities     *bool                     `json:"hasIdentities,omitempty"`
	HasIdentitiesWith []*UserIdentityWhereInput `json:"hasIdentitiesWith,omitempty"`

	// "login_profile" edge predicates.
	HasLoginProfile     *bool                         `json:"hasLoginProfile,omitempty"`
	HasLoginProfileWith []*UserLoginProfileWhereInput `json:"hasLoginProfileWith,omitempty"`

	// "passwords" edge predicates.
	HasPasswords     *bool                     `json:"hasPasswords,omitempty"`
	HasPasswordsWith []*UserPasswordWhereInput `json:"hasPasswordsWith,omitempty"`

	// "devices" edge predicates.
	HasDevices     *bool                   `json:"hasDevices,omitempty"`
	HasDevicesWith []*UserDeviceWhereInput `json:"hasDevicesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, user.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, user.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, user.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, user.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, user.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, user.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, user.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, user.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, user.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, user.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, user.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, user.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, user.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, user.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, user.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, user.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, user.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, user.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, user.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, user.UpdatedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}
	if i.PrincipalName != nil {
		predicates = append(predicates, user.PrincipalNameEQ(*i.PrincipalName))
	}
	if i.PrincipalNameNEQ != nil {
		predicates = append(predicates, user.PrincipalNameNEQ(*i.PrincipalNameNEQ))
	}
	if len(i.PrincipalNameIn) > 0 {
		predicates = append(predicates, user.PrincipalNameIn(i.PrincipalNameIn...))
	}
	if len(i.PrincipalNameNotIn) > 0 {
		predicates = append(predicates, user.PrincipalNameNotIn(i.PrincipalNameNotIn...))
	}
	if i.PrincipalNameGT != nil {
		predicates = append(predicates, user.PrincipalNameGT(*i.PrincipalNameGT))
	}
	if i.PrincipalNameGTE != nil {
		predicates = append(predicates, user.PrincipalNameGTE(*i.PrincipalNameGTE))
	}
	if i.PrincipalNameLT != nil {
		predicates = append(predicates, user.PrincipalNameLT(*i.PrincipalNameLT))
	}
	if i.PrincipalNameLTE != nil {
		predicates = append(predicates, user.PrincipalNameLTE(*i.PrincipalNameLTE))
	}
	if i.PrincipalNameContains != nil {
		predicates = append(predicates, user.PrincipalNameContains(*i.PrincipalNameContains))
	}
	if i.PrincipalNameHasPrefix != nil {
		predicates = append(predicates, user.PrincipalNameHasPrefix(*i.PrincipalNameHasPrefix))
	}
	if i.PrincipalNameHasSuffix != nil {
		predicates = append(predicates, user.PrincipalNameHasSuffix(*i.PrincipalNameHasSuffix))
	}
	if i.PrincipalNameEqualFold != nil {
		predicates = append(predicates, user.PrincipalNameEqualFold(*i.PrincipalNameEqualFold))
	}
	if i.PrincipalNameContainsFold != nil {
		predicates = append(predicates, user.PrincipalNameContainsFold(*i.PrincipalNameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, user.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, user.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, user.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, user.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, user.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, user.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, user.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, user.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, user.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, user.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, user.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, user.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, user.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.CreationType != nil {
		predicates = append(predicates, user.CreationTypeEQ(*i.CreationType))
	}
	if i.CreationTypeNEQ != nil {
		predicates = append(predicates, user.CreationTypeNEQ(*i.CreationTypeNEQ))
	}
	if len(i.CreationTypeIn) > 0 {
		predicates = append(predicates, user.CreationTypeIn(i.CreationTypeIn...))
	}
	if len(i.CreationTypeNotIn) > 0 {
		predicates = append(predicates, user.CreationTypeNotIn(i.CreationTypeNotIn...))
	}
	if i.RegisterIP != nil {
		predicates = append(predicates, user.RegisterIPEQ(*i.RegisterIP))
	}
	if i.RegisterIPNEQ != nil {
		predicates = append(predicates, user.RegisterIPNEQ(*i.RegisterIPNEQ))
	}
	if len(i.RegisterIPIn) > 0 {
		predicates = append(predicates, user.RegisterIPIn(i.RegisterIPIn...))
	}
	if len(i.RegisterIPNotIn) > 0 {
		predicates = append(predicates, user.RegisterIPNotIn(i.RegisterIPNotIn...))
	}
	if i.RegisterIPGT != nil {
		predicates = append(predicates, user.RegisterIPGT(*i.RegisterIPGT))
	}
	if i.RegisterIPGTE != nil {
		predicates = append(predicates, user.RegisterIPGTE(*i.RegisterIPGTE))
	}
	if i.RegisterIPLT != nil {
		predicates = append(predicates, user.RegisterIPLT(*i.RegisterIPLT))
	}
	if i.RegisterIPLTE != nil {
		predicates = append(predicates, user.RegisterIPLTE(*i.RegisterIPLTE))
	}
	if i.RegisterIPContains != nil {
		predicates = append(predicates, user.RegisterIPContains(*i.RegisterIPContains))
	}
	if i.RegisterIPHasPrefix != nil {
		predicates = append(predicates, user.RegisterIPHasPrefix(*i.RegisterIPHasPrefix))
	}
	if i.RegisterIPHasSuffix != nil {
		predicates = append(predicates, user.RegisterIPHasSuffix(*i.RegisterIPHasSuffix))
	}
	if i.RegisterIPEqualFold != nil {
		predicates = append(predicates, user.RegisterIPEqualFold(*i.RegisterIPEqualFold))
	}
	if i.RegisterIPContainsFold != nil {
		predicates = append(predicates, user.RegisterIPContainsFold(*i.RegisterIPContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, user.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, user.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, user.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, user.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, user.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, user.StatusNotNil())
	}

	if i.HasIdentities != nil {
		p := user.HasIdentities()
		if !*i.HasIdentities {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIdentitiesWith) > 0 {
		with := make([]predicate.UserIdentity, 0, len(i.HasIdentitiesWith))
		for _, w := range i.HasIdentitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIdentitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasIdentitiesWith(with...))
	}
	if i.HasLoginProfile != nil {
		p := user.HasLoginProfile()
		if !*i.HasLoginProfile {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLoginProfileWith) > 0 {
		with := make([]predicate.UserLoginProfile, 0, len(i.HasLoginProfileWith))
		for _, w := range i.HasLoginProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLoginProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLoginProfileWith(with...))
	}
	if i.HasPasswords != nil {
		p := user.HasPasswords()
		if !*i.HasPasswords {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPasswordsWith) > 0 {
		with := make([]predicate.UserPassword, 0, len(i.HasPasswordsWith))
		for _, w := range i.HasPasswordsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPasswordsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPasswordsWith(with...))
	}
	if i.HasDevices != nil {
		p := user.HasDevices()
		if !*i.HasDevices {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDevicesWith) > 0 {
		with := make([]predicate.UserDevice, 0, len(i.HasDevicesWith))
		for _, w := range i.HasDevicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDevicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasDevicesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserDeviceWhereInput represents a where input for filtering UserDevice queries.
type UserDeviceWhereInput struct {
	Predicates []predicate.UserDevice  `json:"-"`
	Not        *UserDeviceWhereInput   `json:"not,omitempty"`
	Or         []*UserDeviceWhereInput `json:"or,omitempty"`
	And        []*UserDeviceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "device_uid" field predicates.
	DeviceUID             *string  `json:"deviceUID,omitempty"`
	DeviceUIDNEQ          *string  `json:"deviceUIDNEQ,omitempty"`
	DeviceUIDIn           []string `json:"deviceUIDIn,omitempty"`
	DeviceUIDNotIn        []string `json:"deviceUIDNotIn,omitempty"`
	DeviceUIDGT           *string  `json:"deviceUIDGT,omitempty"`
	DeviceUIDGTE          *string  `json:"deviceUIDGTE,omitempty"`
	DeviceUIDLT           *string  `json:"deviceUIDLT,omitempty"`
	DeviceUIDLTE          *string  `json:"deviceUIDLTE,omitempty"`
	DeviceUIDContains     *string  `json:"deviceUIDContains,omitempty"`
	DeviceUIDHasPrefix    *string  `json:"deviceUIDHasPrefix,omitempty"`
	DeviceUIDHasSuffix    *string  `json:"deviceUIDHasSuffix,omitempty"`
	DeviceUIDEqualFold    *string  `json:"deviceUIDEqualFold,omitempty"`
	DeviceUIDContainsFold *string  `json:"deviceUIDContainsFold,omitempty"`

	// "device_name" field predicates.
	DeviceName             *string  `json:"deviceName,omitempty"`
	DeviceNameNEQ          *string  `json:"deviceNameNEQ,omitempty"`
	DeviceNameIn           []string `json:"deviceNameIn,omitempty"`
	DeviceNameNotIn        []string `json:"deviceNameNotIn,omitempty"`
	DeviceNameGT           *string  `json:"deviceNameGT,omitempty"`
	DeviceNameGTE          *string  `json:"deviceNameGTE,omitempty"`
	DeviceNameLT           *string  `json:"deviceNameLT,omitempty"`
	DeviceNameLTE          *string  `json:"deviceNameLTE,omitempty"`
	DeviceNameContains     *string  `json:"deviceNameContains,omitempty"`
	DeviceNameHasPrefix    *string  `json:"deviceNameHasPrefix,omitempty"`
	DeviceNameHasSuffix    *string  `json:"deviceNameHasSuffix,omitempty"`
	DeviceNameIsNil        bool     `json:"deviceNameIsNil,omitempty"`
	DeviceNameNotNil       bool     `json:"deviceNameNotNil,omitempty"`
	DeviceNameEqualFold    *string  `json:"deviceNameEqualFold,omitempty"`
	DeviceNameContainsFold *string  `json:"deviceNameContainsFold,omitempty"`

	// "system_name" field predicates.
	SystemName             *string  `json:"systemName,omitempty"`
	SystemNameNEQ          *string  `json:"systemNameNEQ,omitempty"`
	SystemNameIn           []string `json:"systemNameIn,omitempty"`
	SystemNameNotIn        []string `json:"systemNameNotIn,omitempty"`
	SystemNameGT           *string  `json:"systemNameGT,omitempty"`
	SystemNameGTE          *string  `json:"systemNameGTE,omitempty"`
	SystemNameLT           *string  `json:"systemNameLT,omitempty"`
	SystemNameLTE          *string  `json:"systemNameLTE,omitempty"`
	SystemNameContains     *string  `json:"systemNameContains,omitempty"`
	SystemNameHasPrefix    *string  `json:"systemNameHasPrefix,omitempty"`
	SystemNameHasSuffix    *string  `json:"systemNameHasSuffix,omitempty"`
	SystemNameIsNil        bool     `json:"systemNameIsNil,omitempty"`
	SystemNameNotNil       bool     `json:"systemNameNotNil,omitempty"`
	SystemNameEqualFold    *string  `json:"systemNameEqualFold,omitempty"`
	SystemNameContainsFold *string  `json:"systemNameContainsFold,omitempty"`

	// "system_version" field predicates.
	SystemVersion             *string  `json:"systemVersion,omitempty"`
	SystemVersionNEQ          *string  `json:"systemVersionNEQ,omitempty"`
	SystemVersionIn           []string `json:"systemVersionIn,omitempty"`
	SystemVersionNotIn        []string `json:"systemVersionNotIn,omitempty"`
	SystemVersionGT           *string  `json:"systemVersionGT,omitempty"`
	SystemVersionGTE          *string  `json:"systemVersionGTE,omitempty"`
	SystemVersionLT           *string  `json:"systemVersionLT,omitempty"`
	SystemVersionLTE          *string  `json:"systemVersionLTE,omitempty"`
	SystemVersionContains     *string  `json:"systemVersionContains,omitempty"`
	SystemVersionHasPrefix    *string  `json:"systemVersionHasPrefix,omitempty"`
	SystemVersionHasSuffix    *string  `json:"systemVersionHasSuffix,omitempty"`
	SystemVersionIsNil        bool     `json:"systemVersionIsNil,omitempty"`
	SystemVersionNotNil       bool     `json:"systemVersionNotNil,omitempty"`
	SystemVersionEqualFold    *string  `json:"systemVersionEqualFold,omitempty"`
	SystemVersionContainsFold *string  `json:"systemVersionContainsFold,omitempty"`

	// "app_version" field predicates.
	AppVersion             *string  `json:"appVersion,omitempty"`
	AppVersionNEQ          *string  `json:"appVersionNEQ,omitempty"`
	AppVersionIn           []string `json:"appVersionIn,omitempty"`
	AppVersionNotIn        []string `json:"appVersionNotIn,omitempty"`
	AppVersionGT           *string  `json:"appVersionGT,omitempty"`
	AppVersionGTE          *string  `json:"appVersionGTE,omitempty"`
	AppVersionLT           *string  `json:"appVersionLT,omitempty"`
	AppVersionLTE          *string  `json:"appVersionLTE,omitempty"`
	AppVersionContains     *string  `json:"appVersionContains,omitempty"`
	AppVersionHasPrefix    *string  `json:"appVersionHasPrefix,omitempty"`
	AppVersionHasSuffix    *string  `json:"appVersionHasSuffix,omitempty"`
	AppVersionIsNil        bool     `json:"appVersionIsNil,omitempty"`
	AppVersionNotNil       bool     `json:"appVersionNotNil,omitempty"`
	AppVersionEqualFold    *string  `json:"appVersionEqualFold,omitempty"`
	AppVersionContainsFold *string  `json:"appVersionContainsFold,omitempty"`

	// "device_model" field predicates.
	DeviceModel             *string  `json:"deviceModel,omitempty"`
	DeviceModelNEQ          *string  `json:"deviceModelNEQ,omitempty"`
	DeviceModelIn           []string `json:"deviceModelIn,omitempty"`
	DeviceModelNotIn        []string `json:"deviceModelNotIn,omitempty"`
	DeviceModelGT           *string  `json:"deviceModelGT,omitempty"`
	DeviceModelGTE          *string  `json:"deviceModelGTE,omitempty"`
	DeviceModelLT           *string  `json:"deviceModelLT,omitempty"`
	DeviceModelLTE          *string  `json:"deviceModelLTE,omitempty"`
	DeviceModelContains     *string  `json:"deviceModelContains,omitempty"`
	DeviceModelHasPrefix    *string  `json:"deviceModelHasPrefix,omitempty"`
	DeviceModelHasSuffix    *string  `json:"deviceModelHasSuffix,omitempty"`
	DeviceModelIsNil        bool     `json:"deviceModelIsNil,omitempty"`
	DeviceModelNotNil       bool     `json:"deviceModelNotNil,omitempty"`
	DeviceModelEqualFold    *string  `json:"deviceModelEqualFold,omitempty"`
	DeviceModelContainsFold *string  `json:"deviceModelContainsFold,omitempty"`

	// "status" field predicates.
	Status       *userdevice.Status  `json:"status,omitempty"`
	StatusNEQ    *userdevice.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []userdevice.Status `json:"statusIn,omitempty"`
	StatusNotIn  []userdevice.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                `json:"statusIsNil,omitempty"`
	StatusNotNil bool                `json:"statusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserDeviceWhereInput) AddPredicates(predicates ...predicate.UserDevice) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserDeviceWhereInput filter on the UserDeviceQuery builder.
func (i *UserDeviceWhereInput) Filter(q *UserDeviceQuery) (*UserDeviceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserDeviceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserDeviceWhereInput is returned in case the UserDeviceWhereInput is empty.
var ErrEmptyUserDeviceWhereInput = errors.New("ent: empty predicate UserDeviceWhereInput")

// P returns a predicate for filtering userdevices.
// An error is returned if the input is empty or invalid.
func (i *UserDeviceWhereInput) P() (predicate.UserDevice, error) {
	var predicates []predicate.UserDevice
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userdevice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserDevice, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userdevice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserDevice, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userdevice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userdevice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userdevice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userdevice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userdevice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userdevice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userdevice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userdevice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userdevice.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, userdevice.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, userdevice.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, userdevice.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, userdevice.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, userdevice.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, userdevice.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, userdevice.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, userdevice.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userdevice.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userdevice.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userdevice.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userdevice.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userdevice.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userdevice.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userdevice.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userdevice.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, userdevice.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, userdevice.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, userdevice.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, userdevice.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, userdevice.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, userdevice.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, userdevice.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, userdevice.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userdevice.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userdevice.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userdevice.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userdevice.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userdevice.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userdevice.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userdevice.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userdevice.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, userdevice.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userdevice.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userdevice.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userdevice.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, userdevice.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, userdevice.UserIDNotNil())
	}
	if i.DeviceUID != nil {
		predicates = append(predicates, userdevice.DeviceUIDEQ(*i.DeviceUID))
	}
	if i.DeviceUIDNEQ != nil {
		predicates = append(predicates, userdevice.DeviceUIDNEQ(*i.DeviceUIDNEQ))
	}
	if len(i.DeviceUIDIn) > 0 {
		predicates = append(predicates, userdevice.DeviceUIDIn(i.DeviceUIDIn...))
	}
	if len(i.DeviceUIDNotIn) > 0 {
		predicates = append(predicates, userdevice.DeviceUIDNotIn(i.DeviceUIDNotIn...))
	}
	if i.DeviceUIDGT != nil {
		predicates = append(predicates, userdevice.DeviceUIDGT(*i.DeviceUIDGT))
	}
	if i.DeviceUIDGTE != nil {
		predicates = append(predicates, userdevice.DeviceUIDGTE(*i.DeviceUIDGTE))
	}
	if i.DeviceUIDLT != nil {
		predicates = append(predicates, userdevice.DeviceUIDLT(*i.DeviceUIDLT))
	}
	if i.DeviceUIDLTE != nil {
		predicates = append(predicates, userdevice.DeviceUIDLTE(*i.DeviceUIDLTE))
	}
	if i.DeviceUIDContains != nil {
		predicates = append(predicates, userdevice.DeviceUIDContains(*i.DeviceUIDContains))
	}
	if i.DeviceUIDHasPrefix != nil {
		predicates = append(predicates, userdevice.DeviceUIDHasPrefix(*i.DeviceUIDHasPrefix))
	}
	if i.DeviceUIDHasSuffix != nil {
		predicates = append(predicates, userdevice.DeviceUIDHasSuffix(*i.DeviceUIDHasSuffix))
	}
	if i.DeviceUIDEqualFold != nil {
		predicates = append(predicates, userdevice.DeviceUIDEqualFold(*i.DeviceUIDEqualFold))
	}
	if i.DeviceUIDContainsFold != nil {
		predicates = append(predicates, userdevice.DeviceUIDContainsFold(*i.DeviceUIDContainsFold))
	}
	if i.DeviceName != nil {
		predicates = append(predicates, userdevice.DeviceNameEQ(*i.DeviceName))
	}
	if i.DeviceNameNEQ != nil {
		predicates = append(predicates, userdevice.DeviceNameNEQ(*i.DeviceNameNEQ))
	}
	if len(i.DeviceNameIn) > 0 {
		predicates = append(predicates, userdevice.DeviceNameIn(i.DeviceNameIn...))
	}
	if len(i.DeviceNameNotIn) > 0 {
		predicates = append(predicates, userdevice.DeviceNameNotIn(i.DeviceNameNotIn...))
	}
	if i.DeviceNameGT != nil {
		predicates = append(predicates, userdevice.DeviceNameGT(*i.DeviceNameGT))
	}
	if i.DeviceNameGTE != nil {
		predicates = append(predicates, userdevice.DeviceNameGTE(*i.DeviceNameGTE))
	}
	if i.DeviceNameLT != nil {
		predicates = append(predicates, userdevice.DeviceNameLT(*i.DeviceNameLT))
	}
	if i.DeviceNameLTE != nil {
		predicates = append(predicates, userdevice.DeviceNameLTE(*i.DeviceNameLTE))
	}
	if i.DeviceNameContains != nil {
		predicates = append(predicates, userdevice.DeviceNameContains(*i.DeviceNameContains))
	}
	if i.DeviceNameHasPrefix != nil {
		predicates = append(predicates, userdevice.DeviceNameHasPrefix(*i.DeviceNameHasPrefix))
	}
	if i.DeviceNameHasSuffix != nil {
		predicates = append(predicates, userdevice.DeviceNameHasSuffix(*i.DeviceNameHasSuffix))
	}
	if i.DeviceNameIsNil {
		predicates = append(predicates, userdevice.DeviceNameIsNil())
	}
	if i.DeviceNameNotNil {
		predicates = append(predicates, userdevice.DeviceNameNotNil())
	}
	if i.DeviceNameEqualFold != nil {
		predicates = append(predicates, userdevice.DeviceNameEqualFold(*i.DeviceNameEqualFold))
	}
	if i.DeviceNameContainsFold != nil {
		predicates = append(predicates, userdevice.DeviceNameContainsFold(*i.DeviceNameContainsFold))
	}
	if i.SystemName != nil {
		predicates = append(predicates, userdevice.SystemNameEQ(*i.SystemName))
	}
	if i.SystemNameNEQ != nil {
		predicates = append(predicates, userdevice.SystemNameNEQ(*i.SystemNameNEQ))
	}
	if len(i.SystemNameIn) > 0 {
		predicates = append(predicates, userdevice.SystemNameIn(i.SystemNameIn...))
	}
	if len(i.SystemNameNotIn) > 0 {
		predicates = append(predicates, userdevice.SystemNameNotIn(i.SystemNameNotIn...))
	}
	if i.SystemNameGT != nil {
		predicates = append(predicates, userdevice.SystemNameGT(*i.SystemNameGT))
	}
	if i.SystemNameGTE != nil {
		predicates = append(predicates, userdevice.SystemNameGTE(*i.SystemNameGTE))
	}
	if i.SystemNameLT != nil {
		predicates = append(predicates, userdevice.SystemNameLT(*i.SystemNameLT))
	}
	if i.SystemNameLTE != nil {
		predicates = append(predicates, userdevice.SystemNameLTE(*i.SystemNameLTE))
	}
	if i.SystemNameContains != nil {
		predicates = append(predicates, userdevice.SystemNameContains(*i.SystemNameContains))
	}
	if i.SystemNameHasPrefix != nil {
		predicates = append(predicates, userdevice.SystemNameHasPrefix(*i.SystemNameHasPrefix))
	}
	if i.SystemNameHasSuffix != nil {
		predicates = append(predicates, userdevice.SystemNameHasSuffix(*i.SystemNameHasSuffix))
	}
	if i.SystemNameIsNil {
		predicates = append(predicates, userdevice.SystemNameIsNil())
	}
	if i.SystemNameNotNil {
		predicates = append(predicates, userdevice.SystemNameNotNil())
	}
	if i.SystemNameEqualFold != nil {
		predicates = append(predicates, userdevice.SystemNameEqualFold(*i.SystemNameEqualFold))
	}
	if i.SystemNameContainsFold != nil {
		predicates = append(predicates, userdevice.SystemNameContainsFold(*i.SystemNameContainsFold))
	}
	if i.SystemVersion != nil {
		predicates = append(predicates, userdevice.SystemVersionEQ(*i.SystemVersion))
	}
	if i.SystemVersionNEQ != nil {
		predicates = append(predicates, userdevice.SystemVersionNEQ(*i.SystemVersionNEQ))
	}
	if len(i.SystemVersionIn) > 0 {
		predicates = append(predicates, userdevice.SystemVersionIn(i.SystemVersionIn...))
	}
	if len(i.SystemVersionNotIn) > 0 {
		predicates = append(predicates, userdevice.SystemVersionNotIn(i.SystemVersionNotIn...))
	}
	if i.SystemVersionGT != nil {
		predicates = append(predicates, userdevice.SystemVersionGT(*i.SystemVersionGT))
	}
	if i.SystemVersionGTE != nil {
		predicates = append(predicates, userdevice.SystemVersionGTE(*i.SystemVersionGTE))
	}
	if i.SystemVersionLT != nil {
		predicates = append(predicates, userdevice.SystemVersionLT(*i.SystemVersionLT))
	}
	if i.SystemVersionLTE != nil {
		predicates = append(predicates, userdevice.SystemVersionLTE(*i.SystemVersionLTE))
	}
	if i.SystemVersionContains != nil {
		predicates = append(predicates, userdevice.SystemVersionContains(*i.SystemVersionContains))
	}
	if i.SystemVersionHasPrefix != nil {
		predicates = append(predicates, userdevice.SystemVersionHasPrefix(*i.SystemVersionHasPrefix))
	}
	if i.SystemVersionHasSuffix != nil {
		predicates = append(predicates, userdevice.SystemVersionHasSuffix(*i.SystemVersionHasSuffix))
	}
	if i.SystemVersionIsNil {
		predicates = append(predicates, userdevice.SystemVersionIsNil())
	}
	if i.SystemVersionNotNil {
		predicates = append(predicates, userdevice.SystemVersionNotNil())
	}
	if i.SystemVersionEqualFold != nil {
		predicates = append(predicates, userdevice.SystemVersionEqualFold(*i.SystemVersionEqualFold))
	}
	if i.SystemVersionContainsFold != nil {
		predicates = append(predicates, userdevice.SystemVersionContainsFold(*i.SystemVersionContainsFold))
	}
	if i.AppVersion != nil {
		predicates = append(predicates, userdevice.AppVersionEQ(*i.AppVersion))
	}
	if i.AppVersionNEQ != nil {
		predicates = append(predicates, userdevice.AppVersionNEQ(*i.AppVersionNEQ))
	}
	if len(i.AppVersionIn) > 0 {
		predicates = append(predicates, userdevice.AppVersionIn(i.AppVersionIn...))
	}
	if len(i.AppVersionNotIn) > 0 {
		predicates = append(predicates, userdevice.AppVersionNotIn(i.AppVersionNotIn...))
	}
	if i.AppVersionGT != nil {
		predicates = append(predicates, userdevice.AppVersionGT(*i.AppVersionGT))
	}
	if i.AppVersionGTE != nil {
		predicates = append(predicates, userdevice.AppVersionGTE(*i.AppVersionGTE))
	}
	if i.AppVersionLT != nil {
		predicates = append(predicates, userdevice.AppVersionLT(*i.AppVersionLT))
	}
	if i.AppVersionLTE != nil {
		predicates = append(predicates, userdevice.AppVersionLTE(*i.AppVersionLTE))
	}
	if i.AppVersionContains != nil {
		predicates = append(predicates, userdevice.AppVersionContains(*i.AppVersionContains))
	}
	if i.AppVersionHasPrefix != nil {
		predicates = append(predicates, userdevice.AppVersionHasPrefix(*i.AppVersionHasPrefix))
	}
	if i.AppVersionHasSuffix != nil {
		predicates = append(predicates, userdevice.AppVersionHasSuffix(*i.AppVersionHasSuffix))
	}
	if i.AppVersionIsNil {
		predicates = append(predicates, userdevice.AppVersionIsNil())
	}
	if i.AppVersionNotNil {
		predicates = append(predicates, userdevice.AppVersionNotNil())
	}
	if i.AppVersionEqualFold != nil {
		predicates = append(predicates, userdevice.AppVersionEqualFold(*i.AppVersionEqualFold))
	}
	if i.AppVersionContainsFold != nil {
		predicates = append(predicates, userdevice.AppVersionContainsFold(*i.AppVersionContainsFold))
	}
	if i.DeviceModel != nil {
		predicates = append(predicates, userdevice.DeviceModelEQ(*i.DeviceModel))
	}
	if i.DeviceModelNEQ != nil {
		predicates = append(predicates, userdevice.DeviceModelNEQ(*i.DeviceModelNEQ))
	}
	if len(i.DeviceModelIn) > 0 {
		predicates = append(predicates, userdevice.DeviceModelIn(i.DeviceModelIn...))
	}
	if len(i.DeviceModelNotIn) > 0 {
		predicates = append(predicates, userdevice.DeviceModelNotIn(i.DeviceModelNotIn...))
	}
	if i.DeviceModelGT != nil {
		predicates = append(predicates, userdevice.DeviceModelGT(*i.DeviceModelGT))
	}
	if i.DeviceModelGTE != nil {
		predicates = append(predicates, userdevice.DeviceModelGTE(*i.DeviceModelGTE))
	}
	if i.DeviceModelLT != nil {
		predicates = append(predicates, userdevice.DeviceModelLT(*i.DeviceModelLT))
	}
	if i.DeviceModelLTE != nil {
		predicates = append(predicates, userdevice.DeviceModelLTE(*i.DeviceModelLTE))
	}
	if i.DeviceModelContains != nil {
		predicates = append(predicates, userdevice.DeviceModelContains(*i.DeviceModelContains))
	}
	if i.DeviceModelHasPrefix != nil {
		predicates = append(predicates, userdevice.DeviceModelHasPrefix(*i.DeviceModelHasPrefix))
	}
	if i.DeviceModelHasSuffix != nil {
		predicates = append(predicates, userdevice.DeviceModelHasSuffix(*i.DeviceModelHasSuffix))
	}
	if i.DeviceModelIsNil {
		predicates = append(predicates, userdevice.DeviceModelIsNil())
	}
	if i.DeviceModelNotNil {
		predicates = append(predicates, userdevice.DeviceModelNotNil())
	}
	if i.DeviceModelEqualFold != nil {
		predicates = append(predicates, userdevice.DeviceModelEqualFold(*i.DeviceModelEqualFold))
	}
	if i.DeviceModelContainsFold != nil {
		predicates = append(predicates, userdevice.DeviceModelContainsFold(*i.DeviceModelContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, userdevice.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, userdevice.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, userdevice.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, userdevice.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, userdevice.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, userdevice.StatusNotNil())
	}

	if i.HasUser != nil {
		p := userdevice.HasUser()
		if !*i.HasUser {
			p = userdevice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userdevice.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserDeviceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userdevice.And(predicates...), nil
	}
}

// UserIdentityWhereInput represents a where input for filtering UserIdentity queries.
type UserIdentityWhereInput struct {
	Predicates []predicate.UserIdentity  `json:"-"`
	Not        *UserIdentityWhereInput   `json:"not,omitempty"`
	Or         []*UserIdentityWhereInput `json:"or,omitempty"`
	And        []*UserIdentityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "kind" field predicates.
	Kind      *useridentity.Kind  `json:"kind,omitempty"`
	KindNEQ   *useridentity.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []useridentity.Kind `json:"kindIn,omitempty"`
	KindNotIn []useridentity.Kind `json:"kindNotIn,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeIsNil        bool     `json:"codeIsNil,omitempty"`
	CodeNotNil       bool     `json:"codeNotNil,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "code_extend" field predicates.
	CodeExtend             *string  `json:"codeExtend,omitempty"`
	CodeExtendNEQ          *string  `json:"codeExtendNEQ,omitempty"`
	CodeExtendIn           []string `json:"codeExtendIn,omitempty"`
	CodeExtendNotIn        []string `json:"codeExtendNotIn,omitempty"`
	CodeExtendGT           *string  `json:"codeExtendGT,omitempty"`
	CodeExtendGTE          *string  `json:"codeExtendGTE,omitempty"`
	CodeExtendLT           *string  `json:"codeExtendLT,omitempty"`
	CodeExtendLTE          *string  `json:"codeExtendLTE,omitempty"`
	CodeExtendContains     *string  `json:"codeExtendContains,omitempty"`
	CodeExtendHasPrefix    *string  `json:"codeExtendHasPrefix,omitempty"`
	CodeExtendHasSuffix    *string  `json:"codeExtendHasSuffix,omitempty"`
	CodeExtendIsNil        bool     `json:"codeExtendIsNil,omitempty"`
	CodeExtendNotNil       bool     `json:"codeExtendNotNil,omitempty"`
	CodeExtendEqualFold    *string  `json:"codeExtendEqualFold,omitempty"`
	CodeExtendContainsFold *string  `json:"codeExtendContainsFold,omitempty"`

	// "status" field predicates.
	Status       *useridentity.Status  `json:"status,omitempty"`
	StatusNEQ    *useridentity.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []useridentity.Status `json:"statusIn,omitempty"`
	StatusNotIn  []useridentity.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil bool                  `json:"statusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserIdentityWhereInput) AddPredicates(predicates ...predicate.UserIdentity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserIdentityWhereInput filter on the UserIdentityQuery builder.
func (i *UserIdentityWhereInput) Filter(q *UserIdentityQuery) (*UserIdentityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserIdentityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserIdentityWhereInput is returned in case the UserIdentityWhereInput is empty.
var ErrEmptyUserIdentityWhereInput = errors.New("ent: empty predicate UserIdentityWhereInput")

// P returns a predicate for filtering useridentities.
// An error is returned if the input is empty or invalid.
func (i *UserIdentityWhereInput) P() (predicate.UserIdentity, error) {
	var predicates []predicate.UserIdentity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, useridentity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserIdentity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, useridentity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserIdentity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, useridentity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, useridentity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, useridentity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, useridentity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, useridentity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, useridentity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, useridentity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, useridentity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, useridentity.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, useridentity.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, useridentity.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, useridentity.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, useridentity.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, useridentity.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, useridentity.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, useridentity.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, useridentity.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, useridentity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, useridentity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, useridentity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, useridentity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, useridentity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, useridentity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, useridentity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, useridentity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, useridentity.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, useridentity.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, useridentity.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, useridentity.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, useridentity.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, useridentity.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, useridentity.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, useridentity.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, useridentity.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, useridentity.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, useridentity.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, useridentity.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, useridentity.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, useridentity.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, useridentity.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, useridentity.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, useridentity.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, useridentity.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, useridentity.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, useridentity.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, useridentity.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, useridentity.UserIDNotNil())
	}
	if i.Kind != nil {
		predicates = append(predicates, useridentity.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, useridentity.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, useridentity.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, useridentity.KindNotIn(i.KindNotIn...))
	}
	if i.Code != nil {
		predicates = append(predicates, useridentity.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, useridentity.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, useridentity.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, useridentity.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, useridentity.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, useridentity.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, useridentity.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, useridentity.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, useridentity.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, useridentity.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, useridentity.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeIsNil {
		predicates = append(predicates, useridentity.CodeIsNil())
	}
	if i.CodeNotNil {
		predicates = append(predicates, useridentity.CodeNotNil())
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, useridentity.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, useridentity.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.CodeExtend != nil {
		predicates = append(predicates, useridentity.CodeExtendEQ(*i.CodeExtend))
	}
	if i.CodeExtendNEQ != nil {
		predicates = append(predicates, useridentity.CodeExtendNEQ(*i.CodeExtendNEQ))
	}
	if len(i.CodeExtendIn) > 0 {
		predicates = append(predicates, useridentity.CodeExtendIn(i.CodeExtendIn...))
	}
	if len(i.CodeExtendNotIn) > 0 {
		predicates = append(predicates, useridentity.CodeExtendNotIn(i.CodeExtendNotIn...))
	}
	if i.CodeExtendGT != nil {
		predicates = append(predicates, useridentity.CodeExtendGT(*i.CodeExtendGT))
	}
	if i.CodeExtendGTE != nil {
		predicates = append(predicates, useridentity.CodeExtendGTE(*i.CodeExtendGTE))
	}
	if i.CodeExtendLT != nil {
		predicates = append(predicates, useridentity.CodeExtendLT(*i.CodeExtendLT))
	}
	if i.CodeExtendLTE != nil {
		predicates = append(predicates, useridentity.CodeExtendLTE(*i.CodeExtendLTE))
	}
	if i.CodeExtendContains != nil {
		predicates = append(predicates, useridentity.CodeExtendContains(*i.CodeExtendContains))
	}
	if i.CodeExtendHasPrefix != nil {
		predicates = append(predicates, useridentity.CodeExtendHasPrefix(*i.CodeExtendHasPrefix))
	}
	if i.CodeExtendHasSuffix != nil {
		predicates = append(predicates, useridentity.CodeExtendHasSuffix(*i.CodeExtendHasSuffix))
	}
	if i.CodeExtendIsNil {
		predicates = append(predicates, useridentity.CodeExtendIsNil())
	}
	if i.CodeExtendNotNil {
		predicates = append(predicates, useridentity.CodeExtendNotNil())
	}
	if i.CodeExtendEqualFold != nil {
		predicates = append(predicates, useridentity.CodeExtendEqualFold(*i.CodeExtendEqualFold))
	}
	if i.CodeExtendContainsFold != nil {
		predicates = append(predicates, useridentity.CodeExtendContainsFold(*i.CodeExtendContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, useridentity.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, useridentity.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, useridentity.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, useridentity.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, useridentity.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, useridentity.StatusNotNil())
	}

	if i.HasUser != nil {
		p := useridentity.HasUser()
		if !*i.HasUser {
			p = useridentity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, useridentity.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserIdentityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return useridentity.And(predicates...), nil
	}
}

// UserLoginProfileWhereInput represents a where input for filtering UserLoginProfile queries.
type UserLoginProfileWhereInput struct {
	Predicates []predicate.UserLoginProfile  `json:"-"`
	Not        *UserLoginProfileWhereInput   `json:"not,omitempty"`
	Or         []*UserLoginProfileWhereInput `json:"or,omitempty"`
	And        []*UserLoginProfileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "can_login" field predicates.
	CanLogin       *bool `json:"canLogin,omitempty"`
	CanLoginNEQ    *bool `json:"canLoginNEQ,omitempty"`
	CanLoginIsNil  bool  `json:"canLoginIsNil,omitempty"`
	CanLoginNotNil bool  `json:"canLoginNotNil,omitempty"`

	// "set_kind" field predicates.
	SetKind      *userloginprofile.SetKind  `json:"setKind,omitempty"`
	SetKindNEQ   *userloginprofile.SetKind  `json:"setKindNEQ,omitempty"`
	SetKindIn    []userloginprofile.SetKind `json:"setKindIn,omitempty"`
	SetKindNotIn []userloginprofile.SetKind `json:"setKindNotIn,omitempty"`

	// "password_reset" field predicates.
	PasswordReset       *bool `json:"passwordReset,omitempty"`
	PasswordResetNEQ    *bool `json:"passwordResetNEQ,omitempty"`
	PasswordResetIsNil  bool  `json:"passwordResetIsNil,omitempty"`
	PasswordResetNotNil bool  `json:"passwordResetNotNil,omitempty"`

	// "verify_device" field predicates.
	VerifyDevice    *bool `json:"verifyDevice,omitempty"`
	VerifyDeviceNEQ *bool `json:"verifyDeviceNEQ,omitempty"`

	// "mfa_enabled" field predicates.
	MfaEnabled       *bool `json:"mfaEnabled,omitempty"`
	MfaEnabledNEQ    *bool `json:"mfaEnabledNEQ,omitempty"`
	MfaEnabledIsNil  bool  `json:"mfaEnabledIsNil,omitempty"`
	MfaEnabledNotNil bool  `json:"mfaEnabledNotNil,omitempty"`

	// "mfa_secret" field predicates.
	MfaSecret             *string  `json:"mfaSecret,omitempty"`
	MfaSecretNEQ          *string  `json:"mfaSecretNEQ,omitempty"`
	MfaSecretIn           []string `json:"mfaSecretIn,omitempty"`
	MfaSecretNotIn        []string `json:"mfaSecretNotIn,omitempty"`
	MfaSecretGT           *string  `json:"mfaSecretGT,omitempty"`
	MfaSecretGTE          *string  `json:"mfaSecretGTE,omitempty"`
	MfaSecretLT           *string  `json:"mfaSecretLT,omitempty"`
	MfaSecretLTE          *string  `json:"mfaSecretLTE,omitempty"`
	MfaSecretContains     *string  `json:"mfaSecretContains,omitempty"`
	MfaSecretHasPrefix    *string  `json:"mfaSecretHasPrefix,omitempty"`
	MfaSecretHasSuffix    *string  `json:"mfaSecretHasSuffix,omitempty"`
	MfaSecretIsNil        bool     `json:"mfaSecretIsNil,omitempty"`
	MfaSecretNotNil       bool     `json:"mfaSecretNotNil,omitempty"`
	MfaSecretEqualFold    *string  `json:"mfaSecretEqualFold,omitempty"`
	MfaSecretContainsFold *string  `json:"mfaSecretContainsFold,omitempty"`

	// "mfa_status" field predicates.
	MfaStatus       *userloginprofile.MfaStatus  `json:"mfaStatus,omitempty"`
	MfaStatusNEQ    *userloginprofile.MfaStatus  `json:"mfaStatusNEQ,omitempty"`
	MfaStatusIn     []userloginprofile.MfaStatus `json:"mfaStatusIn,omitempty"`
	MfaStatusNotIn  []userloginprofile.MfaStatus `json:"mfaStatusNotIn,omitempty"`
	MfaStatusIsNil  bool                         `json:"mfaStatusIsNil,omitempty"`
	MfaStatusNotNil bool                         `json:"mfaStatusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserLoginProfileWhereInput) AddPredicates(predicates ...predicate.UserLoginProfile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserLoginProfileWhereInput filter on the UserLoginProfileQuery builder.
func (i *UserLoginProfileWhereInput) Filter(q *UserLoginProfileQuery) (*UserLoginProfileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserLoginProfileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserLoginProfileWhereInput is returned in case the UserLoginProfileWhereInput is empty.
var ErrEmptyUserLoginProfileWhereInput = errors.New("ent: empty predicate UserLoginProfileWhereInput")

// P returns a predicate for filtering userloginprofiles.
// An error is returned if the input is empty or invalid.
func (i *UserLoginProfileWhereInput) P() (predicate.UserLoginProfile, error) {
	var predicates []predicate.UserLoginProfile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userloginprofile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserLoginProfile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userloginprofile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserLoginProfile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userloginprofile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userloginprofile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userloginprofile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userloginprofile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userloginprofile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userloginprofile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userloginprofile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userloginprofile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userloginprofile.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, userloginprofile.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, userloginprofile.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, userloginprofile.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, userloginprofile.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, userloginprofile.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, userloginprofile.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userloginprofile.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userloginprofile.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userloginprofile.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userloginprofile.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userloginprofile.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userloginprofile.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, userloginprofile.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, userloginprofile.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, userloginprofile.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, userloginprofile.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, userloginprofile.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, userloginprofile.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userloginprofile.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userloginprofile.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, userloginprofile.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userloginprofile.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userloginprofile.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userloginprofile.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, userloginprofile.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, userloginprofile.UserIDNotNil())
	}
	if i.CanLogin != nil {
		predicates = append(predicates, userloginprofile.CanLoginEQ(*i.CanLogin))
	}
	if i.CanLoginNEQ != nil {
		predicates = append(predicates, userloginprofile.CanLoginNEQ(*i.CanLoginNEQ))
	}
	if i.CanLoginIsNil {
		predicates = append(predicates, userloginprofile.CanLoginIsNil())
	}
	if i.CanLoginNotNil {
		predicates = append(predicates, userloginprofile.CanLoginNotNil())
	}
	if i.SetKind != nil {
		predicates = append(predicates, userloginprofile.SetKindEQ(*i.SetKind))
	}
	if i.SetKindNEQ != nil {
		predicates = append(predicates, userloginprofile.SetKindNEQ(*i.SetKindNEQ))
	}
	if len(i.SetKindIn) > 0 {
		predicates = append(predicates, userloginprofile.SetKindIn(i.SetKindIn...))
	}
	if len(i.SetKindNotIn) > 0 {
		predicates = append(predicates, userloginprofile.SetKindNotIn(i.SetKindNotIn...))
	}
	if i.PasswordReset != nil {
		predicates = append(predicates, userloginprofile.PasswordResetEQ(*i.PasswordReset))
	}
	if i.PasswordResetNEQ != nil {
		predicates = append(predicates, userloginprofile.PasswordResetNEQ(*i.PasswordResetNEQ))
	}
	if i.PasswordResetIsNil {
		predicates = append(predicates, userloginprofile.PasswordResetIsNil())
	}
	if i.PasswordResetNotNil {
		predicates = append(predicates, userloginprofile.PasswordResetNotNil())
	}
	if i.VerifyDevice != nil {
		predicates = append(predicates, userloginprofile.VerifyDeviceEQ(*i.VerifyDevice))
	}
	if i.VerifyDeviceNEQ != nil {
		predicates = append(predicates, userloginprofile.VerifyDeviceNEQ(*i.VerifyDeviceNEQ))
	}
	if i.MfaEnabled != nil {
		predicates = append(predicates, userloginprofile.MfaEnabledEQ(*i.MfaEnabled))
	}
	if i.MfaEnabledNEQ != nil {
		predicates = append(predicates, userloginprofile.MfaEnabledNEQ(*i.MfaEnabledNEQ))
	}
	if i.MfaEnabledIsNil {
		predicates = append(predicates, userloginprofile.MfaEnabledIsNil())
	}
	if i.MfaEnabledNotNil {
		predicates = append(predicates, userloginprofile.MfaEnabledNotNil())
	}
	if i.MfaSecret != nil {
		predicates = append(predicates, userloginprofile.MfaSecretEQ(*i.MfaSecret))
	}
	if i.MfaSecretNEQ != nil {
		predicates = append(predicates, userloginprofile.MfaSecretNEQ(*i.MfaSecretNEQ))
	}
	if len(i.MfaSecretIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaSecretIn(i.MfaSecretIn...))
	}
	if len(i.MfaSecretNotIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaSecretNotIn(i.MfaSecretNotIn...))
	}
	if i.MfaSecretGT != nil {
		predicates = append(predicates, userloginprofile.MfaSecretGT(*i.MfaSecretGT))
	}
	if i.MfaSecretGTE != nil {
		predicates = append(predicates, userloginprofile.MfaSecretGTE(*i.MfaSecretGTE))
	}
	if i.MfaSecretLT != nil {
		predicates = append(predicates, userloginprofile.MfaSecretLT(*i.MfaSecretLT))
	}
	if i.MfaSecretLTE != nil {
		predicates = append(predicates, userloginprofile.MfaSecretLTE(*i.MfaSecretLTE))
	}
	if i.MfaSecretContains != nil {
		predicates = append(predicates, userloginprofile.MfaSecretContains(*i.MfaSecretContains))
	}
	if i.MfaSecretHasPrefix != nil {
		predicates = append(predicates, userloginprofile.MfaSecretHasPrefix(*i.MfaSecretHasPrefix))
	}
	if i.MfaSecretHasSuffix != nil {
		predicates = append(predicates, userloginprofile.MfaSecretHasSuffix(*i.MfaSecretHasSuffix))
	}
	if i.MfaSecretIsNil {
		predicates = append(predicates, userloginprofile.MfaSecretIsNil())
	}
	if i.MfaSecretNotNil {
		predicates = append(predicates, userloginprofile.MfaSecretNotNil())
	}
	if i.MfaSecretEqualFold != nil {
		predicates = append(predicates, userloginprofile.MfaSecretEqualFold(*i.MfaSecretEqualFold))
	}
	if i.MfaSecretContainsFold != nil {
		predicates = append(predicates, userloginprofile.MfaSecretContainsFold(*i.MfaSecretContainsFold))
	}
	if i.MfaStatus != nil {
		predicates = append(predicates, userloginprofile.MfaStatusEQ(*i.MfaStatus))
	}
	if i.MfaStatusNEQ != nil {
		predicates = append(predicates, userloginprofile.MfaStatusNEQ(*i.MfaStatusNEQ))
	}
	if len(i.MfaStatusIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaStatusIn(i.MfaStatusIn...))
	}
	if len(i.MfaStatusNotIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaStatusNotIn(i.MfaStatusNotIn...))
	}
	if i.MfaStatusIsNil {
		predicates = append(predicates, userloginprofile.MfaStatusIsNil())
	}
	if i.MfaStatusNotNil {
		predicates = append(predicates, userloginprofile.MfaStatusNotNil())
	}

	if i.HasUser != nil {
		p := userloginprofile.HasUser()
		if !*i.HasUser {
			p = userloginprofile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userloginprofile.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserLoginProfileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userloginprofile.And(predicates...), nil
	}
}

// UserPasswordWhereInput represents a where input for filtering UserPassword queries.
type UserPasswordWhereInput struct {
	Predicates []predicate.UserPassword  `json:"-"`
	Not        *UserPasswordWhereInput   `json:"not,omitempty"`
	Or         []*UserPasswordWhereInput `json:"or,omitempty"`
	And        []*UserPasswordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "scene" field predicates.
	Scene       *userpassword.Scene  `json:"scene,omitempty"`
	SceneNEQ    *userpassword.Scene  `json:"sceneNEQ,omitempty"`
	SceneIn     []userpassword.Scene `json:"sceneIn,omitempty"`
	SceneNotIn  []userpassword.Scene `json:"sceneNotIn,omitempty"`
	SceneIsNil  bool                 `json:"sceneIsNil,omitempty"`
	SceneNotNil bool                 `json:"sceneNotNil,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "status" field predicates.
	Status       *userpassword.Status  `json:"status,omitempty"`
	StatusNEQ    *userpassword.Status  `json:"statusNEQ,omitempty"`
	StatusIn     []userpassword.Status `json:"statusIn,omitempty"`
	StatusNotIn  []userpassword.Status `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil bool                  `json:"statusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserPasswordWhereInput) AddPredicates(predicates ...predicate.UserPassword) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserPasswordWhereInput filter on the UserPasswordQuery builder.
func (i *UserPasswordWhereInput) Filter(q *UserPasswordQuery) (*UserPasswordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserPasswordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserPasswordWhereInput is returned in case the UserPasswordWhereInput is empty.
var ErrEmptyUserPasswordWhereInput = errors.New("ent: empty predicate UserPasswordWhereInput")

// P returns a predicate for filtering userpasswords.
// An error is returned if the input is empty or invalid.
func (i *UserPasswordWhereInput) P() (predicate.UserPassword, error) {
	var predicates []predicate.UserPassword
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userpassword.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserPassword, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userpassword.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserPassword, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userpassword.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userpassword.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userpassword.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userpassword.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userpassword.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userpassword.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userpassword.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userpassword.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userpassword.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, userpassword.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, userpassword.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, userpassword.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, userpassword.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, userpassword.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, userpassword.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, userpassword.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, userpassword.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userpassword.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userpassword.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userpassword.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userpassword.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userpassword.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userpassword.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userpassword.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userpassword.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, userpassword.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, userpassword.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, userpassword.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, userpassword.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, userpassword.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, userpassword.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, userpassword.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, userpassword.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userpassword.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userpassword.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userpassword.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userpassword.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userpassword.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userpassword.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userpassword.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userpassword.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, userpassword.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userpassword.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userpassword.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userpassword.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, userpassword.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, userpassword.UserIDNotNil())
	}
	if i.Scene != nil {
		predicates = append(predicates, userpassword.SceneEQ(*i.Scene))
	}
	if i.SceneNEQ != nil {
		predicates = append(predicates, userpassword.SceneNEQ(*i.SceneNEQ))
	}
	if len(i.SceneIn) > 0 {
		predicates = append(predicates, userpassword.SceneIn(i.SceneIn...))
	}
	if len(i.SceneNotIn) > 0 {
		predicates = append(predicates, userpassword.SceneNotIn(i.SceneNotIn...))
	}
	if i.SceneIsNil {
		predicates = append(predicates, userpassword.SceneIsNil())
	}
	if i.SceneNotNil {
		predicates = append(predicates, userpassword.SceneNotNil())
	}
	if i.Password != nil {
		predicates = append(predicates, userpassword.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, userpassword.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, userpassword.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, userpassword.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, userpassword.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, userpassword.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, userpassword.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, userpassword.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, userpassword.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, userpassword.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, userpassword.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, userpassword.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, userpassword.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, userpassword.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, userpassword.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, userpassword.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, userpassword.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, userpassword.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, userpassword.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, userpassword.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, userpassword.StatusNotNil())
	}

	if i.HasUser != nil {
		p := userpassword.HasUser()
		if !*i.HasUser {
			p = userpassword.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userpassword.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserPasswordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userpassword.And(predicates...), nil
	}
}
